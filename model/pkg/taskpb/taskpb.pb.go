// Code generated by protoc-gen-gogo.
// source: taskpb.proto
// DO NOT EDIT!

/*
	Package taskpb is a generated protocol buffer package.

	It is generated from these files:
		taskpb.proto

	It has these top-level messages:
		TaskMeta
		TaskRangeSplit
		TaskRangeMerge
		TaskRangeTransfer
		TaskRangeFailover
		TaskRangeDelete
		TaskRangeLeaderTransfer
		TaskNodeLogout
		TaskNodeLogin
		TaskNodeDeleteRanges
		TaskNodeCreateRanges
		TaskNodeFailOver
		TaskRangeAddPeer
		TaskRangeDelPeer
		TaskRangeOffline
		TaskRangeCreate
		TaskRangeEmpty
		TaskTableCreate
		TaskTableDelete
		Task
*/
package taskpb

import (
	"fmt"
	"io"
	"math"

	proto "github.com/golang/protobuf/proto"

	metapb "model/pkg/metapb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TaskType int32

const (
	TaskType_RangeSplit          TaskType = 0
	TaskType_RangeMerge          TaskType = 1
	TaskType_RangeTransfer       TaskType = 2
	TaskType_RangeFailOver       TaskType = 3
	TaskType_RangeDelete         TaskType = 4
	TaskType_RangeLeaderTransfer TaskType = 5
	TaskType_NodeLogout          TaskType = 6
	TaskType_NodeLogin           TaskType = 7
	TaskType_NodeFailOver        TaskType = 8
	TaskType_RangeAddPeer        TaskType = 9
	TaskType_RangeDelPeer        TaskType = 10
	TaskType_RangeOffline        TaskType = 11
	TaskType_NodeDeleteRanges    TaskType = 12
	TaskType_RangeCreate         TaskType = 13
	TaskType_NodeCreateRanges    TaskType = 14
	// 空任务，新分裂的分片才会用
	TaskType_EmptyRangeTask TaskType = 15
	TaskType_TableCreate    TaskType = 16
	TaskType_TableDelete    TaskType = 17
)

var TaskType_name = map[int32]string{
	0:  "RangeSplit",
	1:  "RangeMerge",
	2:  "RangeTransfer",
	3:  "RangeFailOver",
	4:  "RangeDelete",
	5:  "RangeLeaderTransfer",
	6:  "NodeLogout",
	7:  "NodeLogin",
	8:  "NodeFailOver",
	9:  "RangeAddPeer",
	10: "RangeDelPeer",
	11: "RangeOffline",
	12: "NodeDeleteRanges",
	13: "RangeCreate",
	14: "NodeCreateRanges",
	15: "EmptyRangeTask",
	16: "TableCreate",
	17: "TableDelete",
}
var TaskType_value = map[string]int32{
	"RangeSplit":          0,
	"RangeMerge":          1,
	"RangeTransfer":       2,
	"RangeFailOver":       3,
	"RangeDelete":         4,
	"RangeLeaderTransfer": 5,
	"NodeLogout":          6,
	"NodeLogin":           7,
	"NodeFailOver":        8,
	"RangeAddPeer":        9,
	"RangeDelPeer":        10,
	"RangeOffline":        11,
	"NodeDeleteRanges":    12,
	"RangeCreate":         13,
	"NodeCreateRanges":    14,
	"EmptyRangeTask":      15,
	"TableCreate":         16,
	"TableDelete":         17,
}

func (x TaskType) String() string {
	return proto.EnumName(TaskType_name, int32(x))
}
func (TaskType) EnumDescriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{0} }

type TaskState int32

const (
	TaskState_TaskWaiting TaskState = 0
	TaskState_TaskRunning TaskState = 1
	TaskState_TaskSuccess TaskState = 2
	TaskState_TaskFail    TaskState = 3
	TaskState_TaskTimeout TaskState = 4
	TaskState_TaskHangUp  TaskState = 5
	TaskState_TaskPause   TaskState = 6
	TaskState_TaskCancel  TaskState = 7
)

var TaskState_name = map[int32]string{
	0: "TaskWaiting",
	1: "TaskRunning",
	2: "TaskSuccess",
	3: "TaskFail",
	4: "TaskTimeout",
	5: "TaskHangUp",
	6: "TaskPause",
	7: "TaskCancel",
}
var TaskState_value = map[string]int32{
	"TaskWaiting": 0,
	"TaskRunning": 1,
	"TaskSuccess": 2,
	"TaskFail":    3,
	"TaskTimeout": 4,
	"TaskHangUp":  5,
	"TaskPause":   6,
	"TaskCancel":  7,
}

func (x TaskState) String() string {
	return proto.EnumName(TaskState_name, int32(x))
}
func (TaskState) EnumDescriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{1} }

type TaskMeta struct {
	TaskId     uint64    `protobuf:"varint,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	CreateTime int64     `protobuf:"varint,2,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	State      TaskState `protobuf:"varint,3,opt,name=state,proto3,enum=taskpb.TaskState" json:"state,omitempty"`
	Timeout    uint64    `protobuf:"varint,5,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *TaskMeta) Reset()                    { *m = TaskMeta{} }
func (m *TaskMeta) String() string            { return proto.CompactTextString(m) }
func (*TaskMeta) ProtoMessage()               {}
func (*TaskMeta) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{0} }

func (m *TaskMeta) GetTaskId() uint64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *TaskMeta) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *TaskMeta) GetState() TaskState {
	if m != nil {
		return m.State
	}
	return TaskState_TaskWaiting
}

func (m *TaskMeta) GetTimeout() uint64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type TaskRangeSplit struct {
	Range        *metapb.Range `protobuf:"bytes,1,opt,name=range" json:"range,omitempty"`
	LeftRangeId  uint64        `protobuf:"varint,2,opt,name=left_range_id,json=leftRangeId,proto3" json:"left_range_id,omitempty"`
	RightRangeId uint64        `protobuf:"varint,3,opt,name=right_range_id,json=rightRangeId,proto3" json:"right_range_id,omitempty"`
	RangeSize    uint64        `protobuf:"varint,4,opt,name=range_size,json=rangeSize,proto3" json:"range_size,omitempty"`
	// 第一次下发任务的时候没有split key，需要data server反馈给master server
	SplitKey []byte `protobuf:"bytes,5,opt,name=split_key,json=splitKey,proto3" json:"split_key,omitempty"`
}

func (m *TaskRangeSplit) Reset()                    { *m = TaskRangeSplit{} }
func (m *TaskRangeSplit) String() string            { return proto.CompactTextString(m) }
func (*TaskRangeSplit) ProtoMessage()               {}
func (*TaskRangeSplit) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{1} }

func (m *TaskRangeSplit) GetRange() *metapb.Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *TaskRangeSplit) GetLeftRangeId() uint64 {
	if m != nil {
		return m.LeftRangeId
	}
	return 0
}

func (m *TaskRangeSplit) GetRightRangeId() uint64 {
	if m != nil {
		return m.RightRangeId
	}
	return 0
}

func (m *TaskRangeSplit) GetRangeSize() uint64 {
	if m != nil {
		return m.RangeSize
	}
	return 0
}

func (m *TaskRangeSplit) GetSplitKey() []byte {
	if m != nil {
		return m.SplitKey
	}
	return nil
}

type TaskRangeMerge struct {
}

func (m *TaskRangeMerge) Reset()                    { *m = TaskRangeMerge{} }
func (m *TaskRangeMerge) String() string            { return proto.CompactTextString(m) }
func (*TaskRangeMerge) ProtoMessage()               {}
func (*TaskRangeMerge) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{2} }

type TaskRangeTransfer struct {
	Range    *metapb.Range `protobuf:"bytes,1,opt,name=range" json:"range,omitempty"`
	UpPeer   *metapb.Peer  `protobuf:"bytes,2,opt,name=up_peer,json=upPeer" json:"up_peer,omitempty"`
	DownPeer *metapb.Peer  `protobuf:"bytes,3,opt,name=down_peer,json=downPeer" json:"down_peer,omitempty"`
}

func (m *TaskRangeTransfer) Reset()                    { *m = TaskRangeTransfer{} }
func (m *TaskRangeTransfer) String() string            { return proto.CompactTextString(m) }
func (*TaskRangeTransfer) ProtoMessage()               {}
func (*TaskRangeTransfer) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{3} }

func (m *TaskRangeTransfer) GetRange() *metapb.Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *TaskRangeTransfer) GetUpPeer() *metapb.Peer {
	if m != nil {
		return m.UpPeer
	}
	return nil
}

func (m *TaskRangeTransfer) GetDownPeer() *metapb.Peer {
	if m != nil {
		return m.DownPeer
	}
	return nil
}

type TaskRangeFailover struct {
	Range    *metapb.Range `protobuf:"bytes,1,opt,name=range" json:"range,omitempty"`
	UpPeer   *metapb.Peer  `protobuf:"bytes,2,opt,name=up_peer,json=upPeer" json:"up_peer,omitempty"`
	DownPeer *metapb.Peer  `protobuf:"bytes,3,opt,name=down_peer,json=downPeer" json:"down_peer,omitempty"`
}

func (m *TaskRangeFailover) Reset()                    { *m = TaskRangeFailover{} }
func (m *TaskRangeFailover) String() string            { return proto.CompactTextString(m) }
func (*TaskRangeFailover) ProtoMessage()               {}
func (*TaskRangeFailover) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{4} }

func (m *TaskRangeFailover) GetRange() *metapb.Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *TaskRangeFailover) GetUpPeer() *metapb.Peer {
	if m != nil {
		return m.UpPeer
	}
	return nil
}

func (m *TaskRangeFailover) GetDownPeer() *metapb.Peer {
	if m != nil {
		return m.DownPeer
	}
	return nil
}

type TaskRangeDelete struct {
	Range *metapb.Range `protobuf:"bytes,1,opt,name=range" json:"range,omitempty"`
}

func (m *TaskRangeDelete) Reset()                    { *m = TaskRangeDelete{} }
func (m *TaskRangeDelete) String() string            { return proto.CompactTextString(m) }
func (*TaskRangeDelete) ProtoMessage()               {}
func (*TaskRangeDelete) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{5} }

func (m *TaskRangeDelete) GetRange() *metapb.Range {
	if m != nil {
		return m.Range
	}
	return nil
}

type TaskRangeLeaderTransfer struct {
	Range     *metapb.Range `protobuf:"bytes,1,opt,name=range" json:"range,omitempty"`
	ExpLeader *metapb.Peer  `protobuf:"bytes,2,opt,name=exp_leader,json=expLeader" json:"exp_leader,omitempty"`
	PreLeader *metapb.Peer  `protobuf:"bytes,3,opt,name=pre_leader,json=preLeader" json:"pre_leader,omitempty"`
}

func (m *TaskRangeLeaderTransfer) Reset()                    { *m = TaskRangeLeaderTransfer{} }
func (m *TaskRangeLeaderTransfer) String() string            { return proto.CompactTextString(m) }
func (*TaskRangeLeaderTransfer) ProtoMessage()               {}
func (*TaskRangeLeaderTransfer) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{6} }

func (m *TaskRangeLeaderTransfer) GetRange() *metapb.Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *TaskRangeLeaderTransfer) GetExpLeader() *metapb.Peer {
	if m != nil {
		return m.ExpLeader
	}
	return nil
}

func (m *TaskRangeLeaderTransfer) GetPreLeader() *metapb.Peer {
	if m != nil {
		return m.PreLeader
	}
	return nil
}

type TaskNodeLogout struct {
	NodeId uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *TaskNodeLogout) Reset()                    { *m = TaskNodeLogout{} }
func (m *TaskNodeLogout) String() string            { return proto.CompactTextString(m) }
func (*TaskNodeLogout) ProtoMessage()               {}
func (*TaskNodeLogout) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{7} }

func (m *TaskNodeLogout) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

type TaskNodeLogin struct {
	NodeId uint64          `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Ranges []*metapb.Range `protobuf:"bytes,2,rep,name=ranges" json:"ranges,omitempty"`
}

func (m *TaskNodeLogin) Reset()                    { *m = TaskNodeLogin{} }
func (m *TaskNodeLogin) String() string            { return proto.CompactTextString(m) }
func (*TaskNodeLogin) ProtoMessage()               {}
func (*TaskNodeLogin) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{8} }

func (m *TaskNodeLogin) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *TaskNodeLogin) GetRanges() []*metapb.Range {
	if m != nil {
		return m.Ranges
	}
	return nil
}

type TaskNodeDeleteRanges struct {
	NodeId   uint64   `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	RangeIds []uint64 `protobuf:"varint,2,rep,packed,name=range_ids,json=rangeIds" json:"range_ids,omitempty"`
}

func (m *TaskNodeDeleteRanges) Reset()                    { *m = TaskNodeDeleteRanges{} }
func (m *TaskNodeDeleteRanges) String() string            { return proto.CompactTextString(m) }
func (*TaskNodeDeleteRanges) ProtoMessage()               {}
func (*TaskNodeDeleteRanges) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{9} }

func (m *TaskNodeDeleteRanges) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *TaskNodeDeleteRanges) GetRangeIds() []uint64 {
	if m != nil {
		return m.RangeIds
	}
	return nil
}

type TaskNodeCreateRanges struct {
	NodeId uint64          `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Ranges []*metapb.Range `protobuf:"bytes,2,rep,name=ranges" json:"ranges,omitempty"`
}

func (m *TaskNodeCreateRanges) Reset()                    { *m = TaskNodeCreateRanges{} }
func (m *TaskNodeCreateRanges) String() string            { return proto.CompactTextString(m) }
func (*TaskNodeCreateRanges) ProtoMessage()               {}
func (*TaskNodeCreateRanges) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{10} }

func (m *TaskNodeCreateRanges) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *TaskNodeCreateRanges) GetRanges() []*metapb.Range {
	if m != nil {
		return m.Ranges
	}
	return nil
}

type TaskNodeFailOver struct {
	NodeId uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *TaskNodeFailOver) Reset()                    { *m = TaskNodeFailOver{} }
func (m *TaskNodeFailOver) String() string            { return proto.CompactTextString(m) }
func (*TaskNodeFailOver) ProtoMessage()               {}
func (*TaskNodeFailOver) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{11} }

func (m *TaskNodeFailOver) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

type TaskRangeAddPeer struct {
	Range *metapb.Range `protobuf:"bytes,1,opt,name=range" json:"range,omitempty"`
	Peer  *metapb.Peer  `protobuf:"bytes,2,opt,name=peer" json:"peer,omitempty"`
}

func (m *TaskRangeAddPeer) Reset()                    { *m = TaskRangeAddPeer{} }
func (m *TaskRangeAddPeer) String() string            { return proto.CompactTextString(m) }
func (*TaskRangeAddPeer) ProtoMessage()               {}
func (*TaskRangeAddPeer) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{12} }

func (m *TaskRangeAddPeer) GetRange() *metapb.Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *TaskRangeAddPeer) GetPeer() *metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

type TaskRangeDelPeer struct {
	Range *metapb.Range `protobuf:"bytes,1,opt,name=range" json:"range,omitempty"`
	Peer  *metapb.Peer  `protobuf:"bytes,2,opt,name=peer" json:"peer,omitempty"`
}

func (m *TaskRangeDelPeer) Reset()                    { *m = TaskRangeDelPeer{} }
func (m *TaskRangeDelPeer) String() string            { return proto.CompactTextString(m) }
func (*TaskRangeDelPeer) ProtoMessage()               {}
func (*TaskRangeDelPeer) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{13} }

func (m *TaskRangeDelPeer) GetRange() *metapb.Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *TaskRangeDelPeer) GetPeer() *metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

type TaskRangeOffline struct {
	Range *metapb.Range `protobuf:"bytes,1,opt,name=range" json:"range,omitempty"`
}

func (m *TaskRangeOffline) Reset()                    { *m = TaskRangeOffline{} }
func (m *TaskRangeOffline) String() string            { return proto.CompactTextString(m) }
func (*TaskRangeOffline) ProtoMessage()               {}
func (*TaskRangeOffline) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{14} }

func (m *TaskRangeOffline) GetRange() *metapb.Range {
	if m != nil {
		return m.Range
	}
	return nil
}

type TaskRangeCreate struct {
	Range *metapb.Range `protobuf:"bytes,1,opt,name=range" json:"range,omitempty"`
}

func (m *TaskRangeCreate) Reset()                    { *m = TaskRangeCreate{} }
func (m *TaskRangeCreate) String() string            { return proto.CompactTextString(m) }
func (*TaskRangeCreate) ProtoMessage()               {}
func (*TaskRangeCreate) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{15} }

func (m *TaskRangeCreate) GetRange() *metapb.Range {
	if m != nil {
		return m.Range
	}
	return nil
}

type TaskRangeEmpty struct {
	RangeId uint64 `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
}

func (m *TaskRangeEmpty) Reset()                    { *m = TaskRangeEmpty{} }
func (m *TaskRangeEmpty) String() string            { return proto.CompactTextString(m) }
func (*TaskRangeEmpty) ProtoMessage()               {}
func (*TaskRangeEmpty) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{16} }

func (m *TaskRangeEmpty) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

type TaskTableCreate struct {
	DbId    uint64          `protobuf:"varint,1,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId uint64          `protobuf:"varint,2,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	Ranges  []*metapb.Range `protobuf:"bytes,3,rep,name=ranges" json:"ranges,omitempty"`
}

func (m *TaskTableCreate) Reset()                    { *m = TaskTableCreate{} }
func (m *TaskTableCreate) String() string            { return proto.CompactTextString(m) }
func (*TaskTableCreate) ProtoMessage()               {}
func (*TaskTableCreate) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{17} }

func (m *TaskTableCreate) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *TaskTableCreate) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *TaskTableCreate) GetRanges() []*metapb.Range {
	if m != nil {
		return m.Ranges
	}
	return nil
}

type TaskTableDelete struct {
	DbId    uint64 `protobuf:"varint,1,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId uint64 `protobuf:"varint,2,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
}

func (m *TaskTableDelete) Reset()                    { *m = TaskTableDelete{} }
func (m *TaskTableDelete) String() string            { return proto.CompactTextString(m) }
func (*TaskTableDelete) ProtoMessage()               {}
func (*TaskTableDelete) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{18} }

func (m *TaskTableDelete) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *TaskTableDelete) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

type Task struct {
	Type                TaskType                 `protobuf:"varint,1,opt,name=type,proto3,enum=taskpb.TaskType" json:"type,omitempty"`
	Meta                *TaskMeta                `protobuf:"bytes,2,opt,name=meta" json:"meta,omitempty"`
	RangeSplit          *TaskRangeSplit          `protobuf:"bytes,3,opt,name=range_split,json=rangeSplit" json:"range_split,omitempty"`
	RangeMerge          *TaskRangeMerge          `protobuf:"bytes,4,opt,name=range_merge,json=rangeMerge" json:"range_merge,omitempty"`
	RangeTransfer       *TaskRangeTransfer       `protobuf:"bytes,5,opt,name=range_transfer,json=rangeTransfer" json:"range_transfer,omitempty"`
	RangeFailover       *TaskRangeFailover       `protobuf:"bytes,6,opt,name=range_failover,json=rangeFailover" json:"range_failover,omitempty"`
	RangeDelete         *TaskRangeDelete         `protobuf:"bytes,7,opt,name=range_delete,json=rangeDelete" json:"range_delete,omitempty"`
	RangeLeaderTransfer *TaskRangeLeaderTransfer `protobuf:"bytes,8,opt,name=range_leader_transfer,json=rangeLeaderTransfer" json:"range_leader_transfer,omitempty"`
	NodeLogout          *TaskNodeLogout          `protobuf:"bytes,9,opt,name=node_logout,json=nodeLogout" json:"node_logout,omitempty"`
	NodeLogin           *TaskNodeLogin           `protobuf:"bytes,10,opt,name=node_login,json=nodeLogin" json:"node_login,omitempty"`
	NodeFailover        *TaskNodeFailOver        `protobuf:"bytes,11,opt,name=node_failover,json=nodeFailover" json:"node_failover,omitempty"`
	RangeAddPeer        *TaskRangeAddPeer        `protobuf:"bytes,12,opt,name=range_add_peer,json=rangeAddPeer" json:"range_add_peer,omitempty"`
	RangeDelPeer        *TaskRangeDelPeer        `protobuf:"bytes,13,opt,name=range_del_peer,json=rangeDelPeer" json:"range_del_peer,omitempty"`
	RangeOffline        *TaskRangeOffline        `protobuf:"bytes,14,opt,name=range_offline,json=rangeOffline" json:"range_offline,omitempty"`
	NodeDeleteRanges    *TaskNodeDeleteRanges    `protobuf:"bytes,15,opt,name=node_delete_ranges,json=nodeDeleteRanges" json:"node_delete_ranges,omitempty"`
	RangeCreate         *TaskRangeCreate         `protobuf:"bytes,16,opt,name=range_create,json=rangeCreate" json:"range_create,omitempty"`
	NodeCreateRanges    *TaskNodeCreateRanges    `protobuf:"bytes,17,opt,name=node_create_ranges,json=nodeCreateRanges" json:"node_create_ranges,omitempty"`
	RangeEmpty          *TaskRangeEmpty          `protobuf:"bytes,18,opt,name=range_empty,json=rangeEmpty" json:"range_empty,omitempty"`
	TableCreate         *TaskTableCreate         `protobuf:"bytes,19,opt,name=table_create,json=tableCreate" json:"table_create,omitempty"`
	TableDelete         *TaskTableDelete         `protobuf:"bytes,20,opt,name=table_delete,json=tableDelete" json:"table_delete,omitempty"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (m *Task) String() string            { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptorTaskpb, []int{19} }

func (m *Task) GetType() TaskType {
	if m != nil {
		return m.Type
	}
	return TaskType_RangeSplit
}

func (m *Task) GetMeta() *TaskMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Task) GetRangeSplit() *TaskRangeSplit {
	if m != nil {
		return m.RangeSplit
	}
	return nil
}

func (m *Task) GetRangeMerge() *TaskRangeMerge {
	if m != nil {
		return m.RangeMerge
	}
	return nil
}

func (m *Task) GetRangeTransfer() *TaskRangeTransfer {
	if m != nil {
		return m.RangeTransfer
	}
	return nil
}

func (m *Task) GetRangeFailover() *TaskRangeFailover {
	if m != nil {
		return m.RangeFailover
	}
	return nil
}

func (m *Task) GetRangeDelete() *TaskRangeDelete {
	if m != nil {
		return m.RangeDelete
	}
	return nil
}

func (m *Task) GetRangeLeaderTransfer() *TaskRangeLeaderTransfer {
	if m != nil {
		return m.RangeLeaderTransfer
	}
	return nil
}

func (m *Task) GetNodeLogout() *TaskNodeLogout {
	if m != nil {
		return m.NodeLogout
	}
	return nil
}

func (m *Task) GetNodeLogin() *TaskNodeLogin {
	if m != nil {
		return m.NodeLogin
	}
	return nil
}

func (m *Task) GetNodeFailover() *TaskNodeFailOver {
	if m != nil {
		return m.NodeFailover
	}
	return nil
}

func (m *Task) GetRangeAddPeer() *TaskRangeAddPeer {
	if m != nil {
		return m.RangeAddPeer
	}
	return nil
}

func (m *Task) GetRangeDelPeer() *TaskRangeDelPeer {
	if m != nil {
		return m.RangeDelPeer
	}
	return nil
}

func (m *Task) GetRangeOffline() *TaskRangeOffline {
	if m != nil {
		return m.RangeOffline
	}
	return nil
}

func (m *Task) GetNodeDeleteRanges() *TaskNodeDeleteRanges {
	if m != nil {
		return m.NodeDeleteRanges
	}
	return nil
}

func (m *Task) GetRangeCreate() *TaskRangeCreate {
	if m != nil {
		return m.RangeCreate
	}
	return nil
}

func (m *Task) GetNodeCreateRanges() *TaskNodeCreateRanges {
	if m != nil {
		return m.NodeCreateRanges
	}
	return nil
}

func (m *Task) GetRangeEmpty() *TaskRangeEmpty {
	if m != nil {
		return m.RangeEmpty
	}
	return nil
}

func (m *Task) GetTableCreate() *TaskTableCreate {
	if m != nil {
		return m.TableCreate
	}
	return nil
}

func (m *Task) GetTableDelete() *TaskTableDelete {
	if m != nil {
		return m.TableDelete
	}
	return nil
}

func init() {
	proto.RegisterType((*TaskMeta)(nil), "taskpb.TaskMeta")
	proto.RegisterType((*TaskRangeSplit)(nil), "taskpb.TaskRangeSplit")
	proto.RegisterType((*TaskRangeMerge)(nil), "taskpb.TaskRangeMerge")
	proto.RegisterType((*TaskRangeTransfer)(nil), "taskpb.TaskRangeTransfer")
	proto.RegisterType((*TaskRangeFailover)(nil), "taskpb.TaskRangeFailover")
	proto.RegisterType((*TaskRangeDelete)(nil), "taskpb.TaskRangeDelete")
	proto.RegisterType((*TaskRangeLeaderTransfer)(nil), "taskpb.TaskRangeLeaderTransfer")
	proto.RegisterType((*TaskNodeLogout)(nil), "taskpb.TaskNodeLogout")
	proto.RegisterType((*TaskNodeLogin)(nil), "taskpb.TaskNodeLogin")
	proto.RegisterType((*TaskNodeDeleteRanges)(nil), "taskpb.TaskNodeDeleteRanges")
	proto.RegisterType((*TaskNodeCreateRanges)(nil), "taskpb.TaskNodeCreateRanges")
	proto.RegisterType((*TaskNodeFailOver)(nil), "taskpb.TaskNodeFailOver")
	proto.RegisterType((*TaskRangeAddPeer)(nil), "taskpb.TaskRangeAddPeer")
	proto.RegisterType((*TaskRangeDelPeer)(nil), "taskpb.TaskRangeDelPeer")
	proto.RegisterType((*TaskRangeOffline)(nil), "taskpb.TaskRangeOffline")
	proto.RegisterType((*TaskRangeCreate)(nil), "taskpb.TaskRangeCreate")
	proto.RegisterType((*TaskRangeEmpty)(nil), "taskpb.TaskRangeEmpty")
	proto.RegisterType((*TaskTableCreate)(nil), "taskpb.TaskTableCreate")
	proto.RegisterType((*TaskTableDelete)(nil), "taskpb.TaskTableDelete")
	proto.RegisterType((*Task)(nil), "taskpb.Task")
	proto.RegisterEnum("taskpb.TaskType", TaskType_name, TaskType_value)
	proto.RegisterEnum("taskpb.TaskState", TaskState_name, TaskState_value)
}
func (m *TaskMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.TaskId))
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.CreateTime))
	}
	if m.State != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.State))
	}
	if m.Timeout != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.Timeout))
	}
	return i, nil
}

func (m *TaskRangeSplit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskRangeSplit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.Range.Size()))
		n1, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.LeftRangeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.LeftRangeId))
	}
	if m.RightRangeId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.RightRangeId))
	}
	if m.RangeSize != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.RangeSize))
	}
	if len(m.SplitKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(len(m.SplitKey)))
		i += copy(dAtA[i:], m.SplitKey)
	}
	return i, nil
}

func (m *TaskRangeMerge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskRangeMerge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TaskRangeTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskRangeTransfer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.Range.Size()))
		n2, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.UpPeer != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.UpPeer.Size()))
		n3, err := m.UpPeer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.DownPeer != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.DownPeer.Size()))
		n4, err := m.DownPeer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *TaskRangeFailover) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskRangeFailover) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.Range.Size()))
		n5, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.UpPeer != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.UpPeer.Size()))
		n6, err := m.UpPeer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.DownPeer != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.DownPeer.Size()))
		n7, err := m.DownPeer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *TaskRangeDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskRangeDelete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.Range.Size()))
		n8, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *TaskRangeLeaderTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskRangeLeaderTransfer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.Range.Size()))
		n9, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.ExpLeader != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.ExpLeader.Size()))
		n10, err := m.ExpLeader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.PreLeader != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.PreLeader.Size()))
		n11, err := m.PreLeader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *TaskNodeLogout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskNodeLogout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.NodeId))
	}
	return i, nil
}

func (m *TaskNodeLogin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskNodeLogin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.NodeId))
	}
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTaskpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TaskNodeDeleteRanges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskNodeDeleteRanges) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.NodeId))
	}
	if len(m.RangeIds) > 0 {
		dAtA13 := make([]byte, len(m.RangeIds)*10)
		var j12 int
		for _, num := range m.RangeIds {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	return i, nil
}

func (m *TaskNodeCreateRanges) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskNodeCreateRanges) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.NodeId))
	}
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTaskpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TaskNodeFailOver) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskNodeFailOver) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.NodeId))
	}
	return i, nil
}

func (m *TaskRangeAddPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskRangeAddPeer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.Range.Size()))
		n14, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Peer != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.Peer.Size()))
		n15, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *TaskRangeDelPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskRangeDelPeer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.Range.Size()))
		n16, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Peer != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.Peer.Size()))
		n17, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *TaskRangeOffline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskRangeOffline) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.Range.Size()))
		n18, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *TaskRangeCreate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskRangeCreate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.Range.Size()))
		n19, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *TaskRangeEmpty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskRangeEmpty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.RangeId))
	}
	return i, nil
}

func (m *TaskTableCreate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskTableCreate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DbId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.DbId))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.TableId))
	}
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTaskpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TaskTableDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TaskTableDelete) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DbId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.DbId))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.TableId))
	}
	return i, nil
}

func (m *Task) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Task) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.Type))
	}
	if m.Meta != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.Meta.Size()))
		n20, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.RangeSplit != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.RangeSplit.Size()))
		n21, err := m.RangeSplit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.RangeMerge != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.RangeMerge.Size()))
		n22, err := m.RangeMerge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.RangeTransfer != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.RangeTransfer.Size()))
		n23, err := m.RangeTransfer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.RangeFailover != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.RangeFailover.Size()))
		n24, err := m.RangeFailover.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.RangeDelete != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.RangeDelete.Size()))
		n25, err := m.RangeDelete.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.RangeLeaderTransfer != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.RangeLeaderTransfer.Size()))
		n26, err := m.RangeLeaderTransfer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.NodeLogout != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.NodeLogout.Size()))
		n27, err := m.NodeLogout.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.NodeLogin != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.NodeLogin.Size()))
		n28, err := m.NodeLogin.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.NodeFailover != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.NodeFailover.Size()))
		n29, err := m.NodeFailover.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.RangeAddPeer != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.RangeAddPeer.Size()))
		n30, err := m.RangeAddPeer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.RangeDelPeer != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.RangeDelPeer.Size()))
		n31, err := m.RangeDelPeer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.RangeOffline != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.RangeOffline.Size()))
		n32, err := m.RangeOffline.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.NodeDeleteRanges != nil {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.NodeDeleteRanges.Size()))
		n33, err := m.NodeDeleteRanges.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.RangeCreate != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.RangeCreate.Size()))
		n34, err := m.RangeCreate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.NodeCreateRanges != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.NodeCreateRanges.Size()))
		n35, err := m.NodeCreateRanges.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.RangeEmpty != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.RangeEmpty.Size()))
		n36, err := m.RangeEmpty.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.TableCreate != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.TableCreate.Size()))
		n37, err := m.TableCreate.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.TableDelete != nil {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintTaskpb(dAtA, i, uint64(m.TableDelete.Size()))
		n38, err := m.TableDelete.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	return i, nil
}

func encodeFixed64Taskpb(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Taskpb(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTaskpb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TaskMeta) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovTaskpb(uint64(m.TaskId))
	}
	if m.CreateTime != 0 {
		n += 1 + sovTaskpb(uint64(m.CreateTime))
	}
	if m.State != 0 {
		n += 1 + sovTaskpb(uint64(m.State))
	}
	if m.Timeout != 0 {
		n += 1 + sovTaskpb(uint64(m.Timeout))
	}
	return n
}

func (m *TaskRangeSplit) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.LeftRangeId != 0 {
		n += 1 + sovTaskpb(uint64(m.LeftRangeId))
	}
	if m.RightRangeId != 0 {
		n += 1 + sovTaskpb(uint64(m.RightRangeId))
	}
	if m.RangeSize != 0 {
		n += 1 + sovTaskpb(uint64(m.RangeSize))
	}
	l = len(m.SplitKey)
	if l > 0 {
		n += 1 + l + sovTaskpb(uint64(l))
	}
	return n
}

func (m *TaskRangeMerge) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TaskRangeTransfer) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.UpPeer != nil {
		l = m.UpPeer.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.DownPeer != nil {
		l = m.DownPeer.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	return n
}

func (m *TaskRangeFailover) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.UpPeer != nil {
		l = m.UpPeer.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.DownPeer != nil {
		l = m.DownPeer.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	return n
}

func (m *TaskRangeDelete) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	return n
}

func (m *TaskRangeLeaderTransfer) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.ExpLeader != nil {
		l = m.ExpLeader.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.PreLeader != nil {
		l = m.PreLeader.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	return n
}

func (m *TaskNodeLogout) Size() (n int) {
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovTaskpb(uint64(m.NodeId))
	}
	return n
}

func (m *TaskNodeLogin) Size() (n int) {
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovTaskpb(uint64(m.NodeId))
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovTaskpb(uint64(l))
		}
	}
	return n
}

func (m *TaskNodeDeleteRanges) Size() (n int) {
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovTaskpb(uint64(m.NodeId))
	}
	if len(m.RangeIds) > 0 {
		l = 0
		for _, e := range m.RangeIds {
			l += sovTaskpb(uint64(e))
		}
		n += 1 + sovTaskpb(uint64(l)) + l
	}
	return n
}

func (m *TaskNodeCreateRanges) Size() (n int) {
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovTaskpb(uint64(m.NodeId))
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovTaskpb(uint64(l))
		}
	}
	return n
}

func (m *TaskNodeFailOver) Size() (n int) {
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovTaskpb(uint64(m.NodeId))
	}
	return n
}

func (m *TaskRangeAddPeer) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	return n
}

func (m *TaskRangeDelPeer) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	return n
}

func (m *TaskRangeOffline) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	return n
}

func (m *TaskRangeCreate) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	return n
}

func (m *TaskRangeEmpty) Size() (n int) {
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovTaskpb(uint64(m.RangeId))
	}
	return n
}

func (m *TaskTableCreate) Size() (n int) {
	var l int
	_ = l
	if m.DbId != 0 {
		n += 1 + sovTaskpb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovTaskpb(uint64(m.TableId))
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovTaskpb(uint64(l))
		}
	}
	return n
}

func (m *TaskTableDelete) Size() (n int) {
	var l int
	_ = l
	if m.DbId != 0 {
		n += 1 + sovTaskpb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovTaskpb(uint64(m.TableId))
	}
	return n
}

func (m *Task) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTaskpb(uint64(m.Type))
	}
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.RangeSplit != nil {
		l = m.RangeSplit.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.RangeMerge != nil {
		l = m.RangeMerge.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.RangeTransfer != nil {
		l = m.RangeTransfer.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.RangeFailover != nil {
		l = m.RangeFailover.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.RangeDelete != nil {
		l = m.RangeDelete.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.RangeLeaderTransfer != nil {
		l = m.RangeLeaderTransfer.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.NodeLogout != nil {
		l = m.NodeLogout.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.NodeLogin != nil {
		l = m.NodeLogin.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.NodeFailover != nil {
		l = m.NodeFailover.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.RangeAddPeer != nil {
		l = m.RangeAddPeer.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.RangeDelPeer != nil {
		l = m.RangeDelPeer.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.RangeOffline != nil {
		l = m.RangeOffline.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.NodeDeleteRanges != nil {
		l = m.NodeDeleteRanges.Size()
		n += 1 + l + sovTaskpb(uint64(l))
	}
	if m.RangeCreate != nil {
		l = m.RangeCreate.Size()
		n += 2 + l + sovTaskpb(uint64(l))
	}
	if m.NodeCreateRanges != nil {
		l = m.NodeCreateRanges.Size()
		n += 2 + l + sovTaskpb(uint64(l))
	}
	if m.RangeEmpty != nil {
		l = m.RangeEmpty.Size()
		n += 2 + l + sovTaskpb(uint64(l))
	}
	if m.TableCreate != nil {
		l = m.TableCreate.Size()
		n += 2 + l + sovTaskpb(uint64(l))
	}
	if m.TableDelete != nil {
		l = m.TableDelete.Size()
		n += 2 + l + sovTaskpb(uint64(l))
	}
	return n
}

func sovTaskpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTaskpb(x uint64) (n int) {
	return sovTaskpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TaskMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TaskId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (TaskState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskRangeSplit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskRangeSplit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskRangeSplit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &metapb.Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftRangeId", wireType)
			}
			m.LeftRangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeftRangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightRangeId", wireType)
			}
			m.RightRangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RightRangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeSize", wireType)
			}
			m.RangeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeSize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitKey = append(m.SplitKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SplitKey == nil {
				m.SplitKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskRangeMerge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskRangeMerge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskRangeMerge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskRangeTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskRangeTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskRangeTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &metapb.Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpPeer == nil {
				m.UpPeer = &metapb.Peer{}
			}
			if err := m.UpPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownPeer == nil {
				m.DownPeer = &metapb.Peer{}
			}
			if err := m.DownPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskRangeFailover) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskRangeFailover: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskRangeFailover: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &metapb.Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpPeer == nil {
				m.UpPeer = &metapb.Peer{}
			}
			if err := m.UpPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownPeer == nil {
				m.DownPeer = &metapb.Peer{}
			}
			if err := m.DownPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskRangeDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskRangeDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskRangeDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &metapb.Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskRangeLeaderTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskRangeLeaderTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskRangeLeaderTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &metapb.Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpLeader == nil {
				m.ExpLeader = &metapb.Peer{}
			}
			if err := m.ExpLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PreLeader == nil {
				m.PreLeader = &metapb.Peer{}
			}
			if err := m.PreLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskNodeLogout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskNodeLogout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskNodeLogout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskNodeLogin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskNodeLogin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskNodeLogin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, &metapb.Range{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskNodeDeleteRanges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskNodeDeleteRanges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskNodeDeleteRanges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTaskpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RangeIds = append(m.RangeIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTaskpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTaskpb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTaskpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RangeIds = append(m.RangeIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskNodeCreateRanges) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskNodeCreateRanges: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskNodeCreateRanges: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, &metapb.Range{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskNodeFailOver) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskNodeFailOver: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskNodeFailOver: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskRangeAddPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskRangeAddPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskRangeAddPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &metapb.Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &metapb.Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskRangeDelPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskRangeDelPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskRangeDelPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &metapb.Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &metapb.Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskRangeOffline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskRangeOffline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskRangeOffline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &metapb.Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskRangeCreate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskRangeCreate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskRangeCreate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &metapb.Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskRangeEmpty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskRangeEmpty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskRangeEmpty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskTableCreate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskTableCreate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskTableCreate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, &metapb.Range{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TaskTableDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskTableDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskTableDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Task) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Task: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Task: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (TaskType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &TaskMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeSplit == nil {
				m.RangeSplit = &TaskRangeSplit{}
			}
			if err := m.RangeSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeMerge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeMerge == nil {
				m.RangeMerge = &TaskRangeMerge{}
			}
			if err := m.RangeMerge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeTransfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeTransfer == nil {
				m.RangeTransfer = &TaskRangeTransfer{}
			}
			if err := m.RangeTransfer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeFailover", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeFailover == nil {
				m.RangeFailover = &TaskRangeFailover{}
			}
			if err := m.RangeFailover.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeDelete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeDelete == nil {
				m.RangeDelete = &TaskRangeDelete{}
			}
			if err := m.RangeDelete.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeLeaderTransfer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeLeaderTransfer == nil {
				m.RangeLeaderTransfer = &TaskRangeLeaderTransfer{}
			}
			if err := m.RangeLeaderTransfer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeLogout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeLogout == nil {
				m.NodeLogout = &TaskNodeLogout{}
			}
			if err := m.NodeLogout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeLogin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeLogin == nil {
				m.NodeLogin = &TaskNodeLogin{}
			}
			if err := m.NodeLogin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeFailover", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeFailover == nil {
				m.NodeFailover = &TaskNodeFailOver{}
			}
			if err := m.NodeFailover.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeAddPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeAddPeer == nil {
				m.RangeAddPeer = &TaskRangeAddPeer{}
			}
			if err := m.RangeAddPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeDelPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeDelPeer == nil {
				m.RangeDelPeer = &TaskRangeDelPeer{}
			}
			if err := m.RangeDelPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeOffline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeOffline == nil {
				m.RangeOffline = &TaskRangeOffline{}
			}
			if err := m.RangeOffline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeDeleteRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeDeleteRanges == nil {
				m.NodeDeleteRanges = &TaskNodeDeleteRanges{}
			}
			if err := m.NodeDeleteRanges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeCreate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeCreate == nil {
				m.RangeCreate = &TaskRangeCreate{}
			}
			if err := m.RangeCreate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCreateRanges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeCreateRanges == nil {
				m.NodeCreateRanges = &TaskNodeCreateRanges{}
			}
			if err := m.NodeCreateRanges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEmpty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeEmpty == nil {
				m.RangeEmpty = &TaskRangeEmpty{}
			}
			if err := m.RangeEmpty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableCreate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableCreate == nil {
				m.TableCreate = &TaskTableCreate{}
			}
			if err := m.TableCreate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableDelete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTaskpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TableDelete == nil {
				m.TableDelete = &TaskTableDelete{}
			}
			if err := m.TableDelete.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTaskpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTaskpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTaskpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTaskpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTaskpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTaskpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTaskpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTaskpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTaskpb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("taskpb.proto", fileDescriptorTaskpb) }

var fileDescriptorTaskpb = []byte{
	// 1202 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xdd, 0x6e, 0xdc, 0xc4,
	0x17, 0x8f, 0xf7, 0xdb, 0x67, 0xbd, 0x9b, 0xc9, 0x24, 0xfd, 0xc7, 0x6d, 0xff, 0xa4, 0x91, 0x69,
	0x45, 0xda, 0x48, 0x41, 0x0a, 0x88, 0x48, 0x95, 0x8a, 0x28, 0x2d, 0x88, 0x40, 0x4a, 0x2a, 0x27,
	0x80, 0xb8, 0x5a, 0x39, 0xf1, 0x64, 0x6b, 0xc5, 0xb1, 0x2d, 0xdb, 0x0b, 0x4d, 0x5f, 0x00, 0x09,
	0xf1, 0x00, 0x7d, 0x17, 0x5e, 0x00, 0x89, 0x1b, 0x2e, 0x78, 0x00, 0x14, 0x5e, 0x04, 0xcd, 0x39,
	0x33, 0xb3, 0xde, 0xec, 0x2e, 0x6c, 0x25, 0x24, 0xae, 0xd6, 0x73, 0xe6, 0xfc, 0x8e, 0xcf, 0xe7,
	0xef, 0x78, 0xc1, 0x29, 0x83, 0xe2, 0x3c, 0x3b, 0xd9, 0xc9, 0xf2, 0xb4, 0x4c, 0x79, 0x8b, 0x4e,
	0xb7, 0x9c, 0x0b, 0x51, 0x06, 0x5a, 0x7a, 0x6b, 0x6d, 0x98, 0x0e, 0x53, 0x7c, 0x7c, 0x57, 0x3e,
	0x91, 0xd4, 0xfb, 0xc1, 0x82, 0xce, 0x71, 0x50, 0x9c, 0x3f, 0x13, 0x65, 0xc0, 0xd7, 0xa1, 0x2d,
	0xa1, 0x83, 0x28, 0x74, 0xad, 0x4d, 0x6b, 0xab, 0xe1, 0xa3, 0xa5, 0xfd, 0x90, 0xdf, 0x81, 0xee,
	0x69, 0x2e, 0x82, 0x52, 0x0c, 0xca, 0xe8, 0x42, 0xb8, 0xb5, 0x4d, 0x6b, 0xab, 0xee, 0x03, 0x89,
	0x8e, 0xa3, 0x0b, 0xc1, 0xdf, 0x81, 0x66, 0x51, 0x06, 0xa5, 0x70, 0xeb, 0x9b, 0xd6, 0x56, 0x7f,
	0x77, 0x65, 0x47, 0x39, 0x24, 0x4d, 0x1f, 0xc9, 0x0b, 0x9f, 0xee, 0xb9, 0x0b, 0x6d, 0x69, 0x22,
	0x1d, 0x95, 0x6e, 0x13, 0x5f, 0xa1, 0x8f, 0xde, 0xcf, 0x16, 0xf4, 0xa5, 0xba, 0x1f, 0x24, 0x43,
	0x71, 0x94, 0xc5, 0x51, 0xc9, 0xdf, 0x86, 0x66, 0x2e, 0x4f, 0xe8, 0x4d, 0x77, 0xb7, 0xb7, 0xa3,
	0x02, 0x42, 0x15, 0x9f, 0xee, 0xb8, 0x07, 0xbd, 0x58, 0x9c, 0x95, 0x03, 0x3c, 0x49, 0xd7, 0x6b,
	0x68, 0xb7, 0x2b, 0x85, 0xa8, 0xb8, 0x1f, 0xf2, 0xbb, 0xd0, 0xcf, 0xa3, 0xe1, 0x8b, 0x8a, 0x52,
	0x1d, 0x95, 0x1c, 0x94, 0x6a, 0xad, 0xb7, 0x00, 0xe8, 0xbe, 0x88, 0x5e, 0x09, 0xb7, 0x81, 0x1a,
	0x36, 0x4a, 0x8e, 0xa2, 0x57, 0x82, 0xdf, 0x06, 0xbb, 0x90, 0x6e, 0x0d, 0xce, 0xc5, 0x25, 0x3a,
	0xef, 0xf8, 0x1d, 0x14, 0x7c, 0x21, 0x2e, 0x3d, 0x56, 0x71, 0xfe, 0x99, 0xc8, 0x87, 0xc2, 0xfb,
	0xd1, 0x82, 0x15, 0x23, 0x3a, 0xce, 0x83, 0xa4, 0x38, 0x13, 0xf9, 0x62, 0x21, 0xdd, 0x83, 0xf6,
	0x28, 0x1b, 0x64, 0x42, 0xe4, 0x18, 0x4c, 0x77, 0xd7, 0xd1, 0x6a, 0xcf, 0x85, 0xc8, 0xfd, 0xd6,
	0x28, 0x93, 0xbf, 0xfc, 0x3e, 0xd8, 0x61, 0xfa, 0x7d, 0x42, 0x8a, 0xf5, 0x19, 0x8a, 0x1d, 0x79,
	0x2d, 0x9f, 0x26, 0x9d, 0xf9, 0x34, 0x88, 0xe2, 0xf4, 0xbb, 0xff, 0xce, 0x99, 0x0f, 0x60, 0xd9,
	0xf8, 0xf2, 0x54, 0xc4, 0xa2, 0x14, 0x0b, 0x79, 0xe2, 0xbd, 0xb6, 0x60, 0xdd, 0x00, 0x0f, 0x44,
	0x10, 0x8a, 0xfc, 0xcd, 0xf2, 0xba, 0x0d, 0x20, 0x5e, 0x66, 0x83, 0x18, 0xa1, 0x33, 0xa3, 0xb1,
	0xc5, 0xcb, 0x8c, 0x2c, 0x4b, 0xe5, 0x2c, 0x17, 0x5a, 0x79, 0x56, 0x44, 0x76, 0x96, 0x2b, 0x37,
	0xbc, 0xfb, 0x54, 0xfe, 0x2f, 0xd3, 0x50, 0x1c, 0xa4, 0xc3, 0x74, 0x54, 0xca, 0x59, 0x4a, 0xd2,
	0x50, 0x54, 0x66, 0x49, 0x1e, 0xf7, 0x43, 0xef, 0x10, 0x7a, 0x15, 0xd5, 0x28, 0x99, 0xab, 0xc9,
	0xef, 0x41, 0x0b, 0xfd, 0x2e, 0xdc, 0xda, 0x66, 0x7d, 0x3a, 0x28, 0x75, 0xe9, 0x1d, 0xc0, 0x9a,
	0x36, 0x48, 0xd9, 0xc4, 0xeb, 0x62, 0xbe, 0xdd, 0xdb, 0x60, 0xeb, 0x39, 0x20, 0xd3, 0x0d, 0xbf,
	0x93, 0xd3, 0x0c, 0x14, 0xde, 0xd7, 0x63, 0x6b, 0x4f, 0x70, 0xbe, 0xff, 0xc9, 0xda, 0x82, 0x5e,
	0x6e, 0x03, 0xd3, 0x76, 0x65, 0xff, 0x1d, 0xca, 0xfe, 0x9b, 0x9b, 0xa3, 0x6f, 0x49, 0x19, 0x2d,
	0x3c, 0x0e, 0x43, 0x6c, 0xb0, 0x85, 0x2a, 0xbc, 0x09, 0x8d, 0xb9, 0x9d, 0x8a, 0x37, 0x13, 0xa6,
	0x9f, 0x8a, 0xf8, 0xdf, 0x34, 0xbd, 0x57, 0x31, 0x7d, 0x78, 0x76, 0x16, 0x47, 0xc9, 0x82, 0x8d,
	0x5d, 0x1d, 0x08, 0x4a, 0xfa, 0x62, 0xb8, 0xed, 0x0a, 0xe9, 0x7c, 0x72, 0x91, 0x95, 0x97, 0xfc,
	0x26, 0x74, 0x0c, 0xc5, 0x51, 0x4a, 0xdb, 0xaa, 0xb2, 0xde, 0x0b, 0x7a, 0xc9, 0x71, 0x70, 0x12,
	0xeb, 0x97, 0xac, 0x42, 0x33, 0x3c, 0x19, 0xab, 0x36, 0xc2, 0x93, 0xfd, 0x50, 0x9a, 0x28, 0xa5,
	0xce, 0x98, 0x4a, 0xdb, 0x78, 0x9e, 0x28, 0x75, 0xfd, 0xef, 0x4a, 0xfd, 0xb8, 0xf2, 0x26, 0x35,
	0xdf, 0x6f, 0xf8, 0x26, 0xef, 0x57, 0x1b, 0x1a, 0xd2, 0x06, 0xbf, 0x0b, 0x8d, 0xf2, 0x32, 0xa3,
	0x34, 0xf4, 0x77, 0x59, 0x75, 0xaf, 0x1c, 0x5f, 0x66, 0xc2, 0xc7, 0x5b, 0xa9, 0x25, 0x3d, 0x51,
	0xb5, 0x99, 0xd0, 0x92, 0x8b, 0xcd, 0xc7, 0x5b, 0xbe, 0x07, 0x5d, 0xc5, 0xef, 0x92, 0xb5, 0xd5,
	0x48, 0xff, 0xaf, 0xaa, 0x3c, 0xde, 0x3d, 0x3e, 0xad, 0x02, 0xda, 0x43, 0x06, 0x78, 0x21, 0x99,
	0x1d, 0x37, 0xc3, 0x2c, 0x20, 0xf2, 0xbe, 0x02, 0xe2, 0x33, 0xff, 0x08, 0xfa, 0x04, 0x2c, 0x15,
	0x4f, 0xe1, 0xde, 0xe8, 0xee, 0xde, 0x9c, 0xc2, 0x6a, 0x22, 0xf3, 0x7b, 0xf9, 0xc4, 0xbe, 0x30,
	0x16, 0xce, 0x14, 0x69, 0xbb, 0xad, 0x39, 0x16, 0x34, 0xab, 0x2b, 0x0b, 0x86, 0xe4, 0x1f, 0x82,
	0x43, 0x16, 0x42, 0x2c, 0x85, 0xdb, 0x46, 0xfc, 0xfa, 0x14, 0x5e, 0x71, 0x07, 0x45, 0xaa, 0xca,
	0x76, 0x04, 0x37, 0x08, 0x4b, 0x2c, 0x38, 0x0e, 0xa3, 0x83, 0x46, 0xee, 0x4c, 0x19, 0x99, 0x64,
	0x65, 0x7f, 0x35, 0x9f, 0x41, 0xd5, 0x7b, 0xd0, 0xc5, 0xa9, 0x8f, 0x91, 0x28, 0x5d, 0x7b, 0x3a,
	0x9b, 0x63, 0x1a, 0xf5, 0x21, 0x19, 0x53, 0xea, 0xfb, 0x00, 0x1a, 0x18, 0x25, 0x2e, 0x20, 0xee,
	0xc6, 0x0c, 0x5c, 0x94, 0xf8, 0x76, 0x62, 0xe8, 0xf5, 0x11, 0xf4, 0x10, 0x65, 0x12, 0xd8, 0x45,
	0xa0, 0x7b, 0x1d, 0xa8, 0x59, 0xc9, 0x77, 0x12, 0x75, 0xc2, 0xf4, 0x7d, 0xa8, 0x0b, 0x10, 0x84,
	0x21, 0x2d, 0x37, 0x67, 0x1a, 0x5f, 0x25, 0x2a, 0x9f, 0xd2, 0xad, 0x69, 0xcb, 0xe0, 0x43, 0x11,
	0x13, 0xbe, 0x37, 0x07, 0xaf, 0xd8, 0x48, 0xe1, 0x35, 0x37, 0x3d, 0x02, 0xaa, 0xe7, 0x20, 0x25,
	0x46, 0x71, 0xfb, 0x73, 0xe0, 0x8a, 0x71, 0x14, 0x5c, 0xf3, 0xcf, 0xe7, 0xc0, 0x31, 0x7a, 0x2a,
	0xfe, 0x40, 0x8d, 0xef, 0x32, 0xda, 0xf8, 0xff, 0xf5, 0x14, 0x54, 0xd7, 0x87, 0xcf, 0x92, 0xeb,
	0x0b, 0xc5, 0x74, 0x12, 0x7d, 0xf8, 0xb9, 0x6c, 0x4e, 0x27, 0xa9, 0xbd, 0x41, 0x9d, 0xa4, 0xa8,
	0x46, 0xfb, 0xa1, 0x3e, 0x23, 0x95, 0x1f, 0x2b, 0xb3, 0xfd, 0xa8, 0x2e, 0x1e, 0xf2, 0x63, 0x62,
	0x15, 0x99, 0x71, 0x14, 0x92, 0xf3, 0x5c, 0x3e, 0x67, 0x1c, 0x91, 0x11, 0xd5, 0x38, 0x12, 0x3b,
	0x3e, 0x94, 0x1f, 0xca, 0x92, 0x70, 0x54, 0x00, 0xab, 0xd3, 0x01, 0x54, 0xe8, 0xd1, 0xef, 0x96,
	0x15, 0xae, 0x34, 0x58, 0x35, 0x46, 0x6b, 0x73, 0xb0, 0x7a, 0x8c, 0xca, 0xf1, 0xe1, 0xc1, 0xef,
	0x35, 0xfa, 0xc8, 0x96, 0x8c, 0xc5, 0xfb, 0x00, 0x63, 0x9a, 0x61, 0x4b, 0xe6, 0x8c, 0x8c, 0xc1,
	0x2c, 0xbe, 0x02, 0xbd, 0x09, 0x46, 0x60, 0x35, 0x23, 0xd2, 0x2d, 0xca, 0xea, 0x7c, 0x19, 0xba,
	0x95, 0xa9, 0x65, 0x0d, 0xbe, 0x0e, 0xab, 0x33, 0x26, 0x90, 0x35, 0xa5, 0xfd, 0xf1, 0x3c, 0xb1,
	0x16, 0xef, 0x81, 0x6d, 0xe6, 0x84, 0xb5, 0x39, 0x03, 0xa7, 0xda, 0xfd, 0xac, 0x23, 0x25, 0xd5,
	0x7e, 0x66, 0xb6, 0x91, 0xa8, 0x9e, 0x64, 0x60, 0x24, 0xaa, 0xcd, 0x58, 0x97, 0xaf, 0x01, 0xbb,
	0xde, 0x42, 0xcc, 0x31, 0x6e, 0x52, 0x12, 0x59, 0x4f, 0xab, 0x55, 0xeb, 0xc9, 0xfa, 0x9c, 0x43,
	0x9f, 0xaa, 0x85, 0x81, 0x07, 0xc5, 0x39, 0x5b, 0x96, 0xd0, 0x4a, 0x31, 0x18, 0x33, 0x02, 0x15,
	0xf2, 0xca, 0x83, 0x9f, 0x2c, 0xb0, 0xcd, 0x1f, 0x0c, 0xba, 0x2e, 0xce, 0xbf, 0x09, 0xa2, 0x32,
	0x4a, 0x86, 0x6c, 0x49, 0x0b, 0xfc, 0x51, 0x92, 0x48, 0x81, 0xa5, 0x05, 0x47, 0xa3, 0xd3, 0x53,
	0x51, 0x14, 0xac, 0xc6, 0x1d, 0x2a, 0x8b, 0x8c, 0x9d, 0x52, 0x8a, 0x45, 0xa2, 0xff, 0x23, 0xac,
	0x21, 0x33, 0x27, 0x05, 0x9f, 0x05, 0xc9, 0xf0, 0xab, 0x8c, 0x35, 0x65, 0xe6, 0xe4, 0xf9, 0x79,
	0x30, 0x2a, 0x04, 0x6b, 0xe9, 0xeb, 0x27, 0x41, 0x72, 0x2a, 0x62, 0xd6, 0xfe, 0x98, 0xfd, 0x72,
	0xb5, 0x61, 0xfd, 0x76, 0xb5, 0x61, 0xfd, 0x71, 0xb5, 0x61, 0xbd, 0xfe, 0x73, 0x63, 0xe9, 0xa4,
	0x85, 0xff, 0xb1, 0xde, 0xfb, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x5f, 0x2f, 0x3a, 0x97, 0x9f, 0x0d,
	0x00, 0x00,
}
