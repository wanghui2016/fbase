// Code generated by protoc-gen-gogo.
// source: metapb.proto
// DO NOT EDIT!

/*
	Package metapb is a generated protocol buffer package.

	It is generated from these files:
		metapb.proto

	It has these top-level messages:
		Cluster
		RaftAddrs
		Node
		Peer
		RangeEpoch
		Range
		Leader
		Replica
		Route
		DataBase
		Column
		Primary
		TableEpoch
		Table
		Option
		Key
		Zone
		Room
		Machine
		RoomV1Policy
		ZoneV1Policy
		DeployV1Policy
		TableRwPolicy
		TableRwSplit
		TableMutliRead
		TableOnlyMaster
		TopologyEpoch
*/
package metapb

import (
	"fmt"
	"io"
	"math"

	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type NodeState int32

const (
	NodeState_N_Invalid   NodeState = 0
	NodeState_N_Login     NodeState = 1
	NodeState_N_Logout    NodeState = 2
	NodeState_N_Doubt     NodeState = 3
	NodeState_N_Tombstone NodeState = 4
	NodeState_N_Upgrade   NodeState = 5
	NodeState_N_Initial   NodeState = 6
)

var NodeState_name = map[int32]string{
	0: "N_Invalid",
	1: "N_Login",
	2: "N_Logout",
	3: "N_Doubt",
	4: "N_Tombstone",
	5: "N_Upgrade",
	6: "N_Initial",
}
var NodeState_value = map[string]int32{
	"N_Invalid":   0,
	"N_Login":     1,
	"N_Logout":    2,
	"N_Doubt":     3,
	"N_Tombstone": 4,
	"N_Upgrade":   5,
	"N_Initial":   6,
}

func (x NodeState) String() string {
	return proto.EnumName(NodeState_name, int32(x))
}
func (NodeState) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{0} }

type RangeState int32

const (
	RangeState_R_Invalid  RangeState = 0
	RangeState_R_Init     RangeState = 1
	RangeState_R_Normal   RangeState = 2
	RangeState_R_Split    RangeState = 3
	RangeState_R_Merge    RangeState = 4
	RangeState_R_Remove   RangeState = 5
	RangeState_R_LoadSnap RangeState = 6
	RangeState_R_Abnormal RangeState = 7
	RangeState_R_Offline  RangeState = 8
)

var RangeState_name = map[int32]string{
	0: "R_Invalid",
	1: "R_Init",
	2: "R_Normal",
	3: "R_Split",
	4: "R_Merge",
	5: "R_Remove",
	6: "R_LoadSnap",
	7: "R_Abnormal",
	8: "R_Offline",
}
var RangeState_value = map[string]int32{
	"R_Invalid":  0,
	"R_Init":     1,
	"R_Normal":   2,
	"R_Split":    3,
	"R_Merge":    4,
	"R_Remove":   5,
	"R_LoadSnap": 6,
	"R_Abnormal": 7,
	"R_Offline":  8,
}

func (x RangeState) String() string {
	return proto.EnumName(RangeState_name, int32(x))
}
func (RangeState) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{1} }

type DataType int32

const (
	DataType_Invalid DataType = 0
	// 8 bit interger
	DataType_Tinyint DataType = 1
	// 16 bit interger
	DataType_Smallint DataType = 2
	// 32 bit interger
	DataType_Int DataType = 3
	// 64 bit interger
	DataType_BigInt DataType = 4
	// 32 bit float
	DataType_Float DataType = 5
	// 64 bit float
	DataType_Double DataType = 6
	// string UTF-8 max size 64 KB
	DataType_Varchar DataType = 7
	// Blob max size 64 KB
	DataType_Binary DataType = 8
	// DataTime 从1970年1月1日以来的天数
	DataType_Date DataType = 9
	// DataTime 从1970年1月1日以来的秒数，精确到纳秒
	DataType_TimeStamp DataType = 10
)

var DataType_name = map[int32]string{
	0:  "Invalid",
	1:  "Tinyint",
	2:  "Smallint",
	3:  "Int",
	4:  "BigInt",
	5:  "Float",
	6:  "Double",
	7:  "Varchar",
	8:  "Binary",
	9:  "Date",
	10: "TimeStamp",
}
var DataType_value = map[string]int32{
	"Invalid":   0,
	"Tinyint":   1,
	"Smallint":  2,
	"Int":       3,
	"BigInt":    4,
	"Float":     5,
	"Double":    6,
	"Varchar":   7,
	"Binary":    8,
	"Date":      9,
	"TimeStamp": 10,
}

func (x DataType) String() string {
	return proto.EnumName(DataType_name, int32(x))
}
func (DataType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{2} }

type KeyType int32

const (
	KeyType_KT_Invalid KeyType = 0
	// +∞ 正无穷
	KeyType_KT_PositiveInfinity KeyType = 1
	// -∞　负无穷
	KeyType_KT_NegativeInfinity KeyType = 2
	// 普通Key
	KeyType_KT_Ordinary KeyType = 3
)

var KeyType_name = map[int32]string{
	0: "KT_Invalid",
	1: "KT_PositiveInfinity",
	2: "KT_NegativeInfinity",
	3: "KT_Ordinary",
}
var KeyType_value = map[string]int32{
	"KT_Invalid":          0,
	"KT_PositiveInfinity": 1,
	"KT_NegativeInfinity": 2,
	"KT_Ordinary":         3,
}

func (x KeyType) String() string {
	return proto.EnumName(KeyType_name, int32(x))
}
func (KeyType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{3} }

type RwPolicy int32

const (
	RwPolicy_RW_Invalid RwPolicy = 0
	// 读写分离
	RwPolicy_RW_Split RwPolicy = 1
	// 混合读
	RwPolicy_RW_MutliRead RwPolicy = 2
	// 仅master读写
	RwPolicy_RW_OnlyMaster RwPolicy = 3
)

var RwPolicy_name = map[int32]string{
	0: "RW_Invalid",
	1: "RW_Split",
	2: "RW_MutliRead",
	3: "RW_OnlyMaster",
}
var RwPolicy_value = map[string]int32{
	"RW_Invalid":    0,
	"RW_Split":      1,
	"RW_MutliRead":  2,
	"RW_OnlyMaster": 3,
}

func (x RwPolicy) String() string {
	return proto.EnumName(RwPolicy_name, int32(x))
}
func (RwPolicy) EnumDescriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{4} }

type Cluster struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// max peer count for a Range.
	// master server will do the auto-balance if Range peer count mismatches.
	MaxPeerCount uint32 `protobuf:"varint,2,opt,name=max_peer_count,json=maxPeerCount,proto3" json:"max_peer_count,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{0} }

func (m *Cluster) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Cluster) GetMaxPeerCount() uint32 {
	if m != nil {
		return m.MaxPeerCount
	}
	return 0
}

type RaftAddrs struct {
	HeartbeatAddr string `protobuf:"bytes,1,opt,name=heartbeat_addr,json=heartbeatAddr,proto3" json:"heartbeat_addr,omitempty"`
	ReplicateAddr string `protobuf:"bytes,2,opt,name=replicate_addr,json=replicateAddr,proto3" json:"replicate_addr,omitempty"`
}

func (m *RaftAddrs) Reset()                    { *m = RaftAddrs{} }
func (m *RaftAddrs) String() string            { return proto.CompactTextString(m) }
func (*RaftAddrs) ProtoMessage()               {}
func (*RaftAddrs) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{1} }

func (m *RaftAddrs) GetHeartbeatAddr() string {
	if m != nil {
		return m.HeartbeatAddr
	}
	return ""
}

func (m *RaftAddrs) GetReplicateAddr() string {
	if m != nil {
		return m.ReplicateAddr
	}
	return ""
}

type Node struct {
	Id        uint64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Address   string     `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	State     NodeState  `protobuf:"varint,3,opt,name=state,proto3,enum=metapb.NodeState" json:"state,omitempty"`
	RaftAddrs *RaftAddrs `protobuf:"bytes,4,opt,name=raft_addrs,json=raftAddrs" json:"raft_addrs,omitempty"`
	Version   string     `protobuf:"bytes,5,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{2} }

func (m *Node) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Node) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Node) GetState() NodeState {
	if m != nil {
		return m.State
	}
	return NodeState_N_Invalid
}

func (m *Node) GetRaftAddrs() *RaftAddrs {
	if m != nil {
		return m.RaftAddrs
	}
	return nil
}

func (m *Node) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type Peer struct {
	Id     uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	NodeId uint64 `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
}

func (m *Peer) Reset()                    { *m = Peer{} }
func (m *Peer) String() string            { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()               {}
func (*Peer) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{3} }

func (m *Peer) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Peer) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

type RangeEpoch struct {
	// Conf change version, auto increment when add or remove peer
	ConfVer uint64 `protobuf:"varint,1,opt,name=conf_ver,json=confVer,proto3" json:"conf_ver,omitempty"`
	// Range version, auto increment when split or merge
	Version uint64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *RangeEpoch) Reset()                    { *m = RangeEpoch{} }
func (m *RangeEpoch) String() string            { return proto.CompactTextString(m) }
func (*RangeEpoch) ProtoMessage()               {}
func (*RangeEpoch) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{4} }

func (m *RangeEpoch) GetConfVer() uint64 {
	if m != nil {
		return m.ConfVer
	}
	return 0
}

func (m *RangeEpoch) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type Range struct {
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Range key range [start_key, end_key).
	StartKey   *Key        `protobuf:"bytes,2,opt,name=start_key,json=startKey" json:"start_key,omitempty"`
	EndKey     *Key        `protobuf:"bytes,3,opt,name=end_key,json=endKey" json:"end_key,omitempty"`
	RangeEpoch *RangeEpoch `protobuf:"bytes,4,opt,name=range_epoch,json=rangeEpoch" json:"range_epoch,omitempty"`
	Peers      []*Peer     `protobuf:"bytes,5,rep,name=peers" json:"peers,omitempty"`
	// Range state
	State      RangeState `protobuf:"varint,6,opt,name=state,proto3,enum=metapb.RangeState" json:"state,omitempty"`
	DbId       uint64     `protobuf:"varint,7,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId    uint64     `protobuf:"varint,8,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	DbName     string     `protobuf:"bytes,9,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	TableName  string     `protobuf:"bytes,10,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	CreateTime int64      `protobuf:"varint,11,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
}

func (m *Range) Reset()                    { *m = Range{} }
func (m *Range) String() string            { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()               {}
func (*Range) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{5} }

func (m *Range) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Range) GetStartKey() *Key {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *Range) GetEndKey() *Key {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *Range) GetRangeEpoch() *RangeEpoch {
	if m != nil {
		return m.RangeEpoch
	}
	return nil
}

func (m *Range) GetPeers() []*Peer {
	if m != nil {
		return m.Peers
	}
	return nil
}

func (m *Range) GetState() RangeState {
	if m != nil {
		return m.State
	}
	return RangeState_R_Invalid
}

func (m *Range) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *Range) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *Range) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *Range) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *Range) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

type Leader struct {
	RangeId  uint64 `protobuf:"varint,1,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	NodeId   uint64 `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	NodeAddr string `protobuf:"bytes,3,opt,name=node_addr,json=nodeAddr,proto3" json:"node_addr,omitempty"`
}

func (m *Leader) Reset()                    { *m = Leader{} }
func (m *Leader) String() string            { return proto.CompactTextString(m) }
func (*Leader) ProtoMessage()               {}
func (*Leader) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{6} }

func (m *Leader) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *Leader) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Leader) GetNodeAddr() string {
	if m != nil {
		return m.NodeAddr
	}
	return ""
}

type Replica struct {
	NodeId   uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	NodeAddr string `protobuf:"bytes,2,opt,name=node_addr,json=nodeAddr,proto3" json:"node_addr,omitempty"`
	LogIndex uint64 `protobuf:"varint,3,opt,name=log_index,json=logIndex,proto3" json:"log_index,omitempty"`
}

func (m *Replica) Reset()                    { *m = Replica{} }
func (m *Replica) String() string            { return proto.CompactTextString(m) }
func (*Replica) ProtoMessage()               {}
func (*Replica) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{7} }

func (m *Replica) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *Replica) GetNodeAddr() string {
	if m != nil {
		return m.NodeAddr
	}
	return ""
}

func (m *Replica) GetLogIndex() uint64 {
	if m != nil {
		return m.LogIndex
	}
	return 0
}

type Route struct {
	Id         uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	StartKey   *Key        `protobuf:"bytes,2,opt,name=start_key,json=startKey" json:"start_key,omitempty"`
	EndKey     *Key        `protobuf:"bytes,3,opt,name=end_key,json=endKey" json:"end_key,omitempty"`
	RangeEpoch *RangeEpoch `protobuf:"bytes,4,opt,name=range_epoch,json=rangeEpoch" json:"range_epoch,omitempty"`
	Leader     *Leader     `protobuf:"bytes,5,opt,name=leader" json:"leader,omitempty"`
	//
	Replicas []*Replica `protobuf:"bytes,6,rep,name=replicas" json:"replicas,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{8} }

func (m *Route) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Route) GetStartKey() *Key {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *Route) GetEndKey() *Key {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *Route) GetRangeEpoch() *RangeEpoch {
	if m != nil {
		return m.RangeEpoch
	}
	return nil
}

func (m *Route) GetLeader() *Leader {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *Route) GetReplicas() []*Replica {
	if m != nil {
		return m.Replicas
	}
	return nil
}

type DataBase struct {
	Name       string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Id         uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Properties string `protobuf:"bytes,3,opt,name=properties,proto3" json:"properties,omitempty"`
	Version    uint64 `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"`
	CreateTime int64  `protobuf:"varint,5,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
}

func (m *DataBase) Reset()                    { *m = DataBase{} }
func (m *DataBase) String() string            { return proto.CompactTextString(m) }
func (*DataBase) ProtoMessage()               {}
func (*DataBase) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{9} }

func (m *DataBase) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DataBase) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DataBase) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *DataBase) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *DataBase) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

type Column struct {
	// max size 128 bytes
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// 列名映射的ID,客户端不可见
	Id       uint64   `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	DataType DataType `protobuf:"varint,3,opt,name=data_type,json=dataType,proto3,enum=metapb.DataType" json:"data_type,omitempty"`
	// 针对int类型,是否是无符号类型
	Unsigned bool `protobuf:"varint,4,opt,name=unsigned,proto3" json:"unsigned,omitempty"`
	// 针对float和varchar类型
	Scale int32 `protobuf:"varint,5,opt,name=scale,proto3" json:"scale,omitempty"`
	// 针对float类型
	Precision int32 `protobuf:"varint,6,opt,name=precision,proto3" json:"precision,omitempty"`
	// 是否可以为空
	Nullable bool `protobuf:"varint,7,opt,name=nullable,proto3" json:"nullable,omitempty"`
	// 是否主键
	PrimaryKey uint64 `protobuf:"varint,8,opt,name=primary_key,json=primaryKey,proto3" json:"primary_key,omitempty"`
	// 列的顺序
	Ordinal int32 `protobuf:"varint,9,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
	// 索引 Binary不支持索引，其他类型列默认均是索引列
	Index        bool   `protobuf:"varint,10,opt,name=index,proto3" json:"index,omitempty"`
	DefaultValue []byte `protobuf:"bytes,11,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	Properties   string `protobuf:"bytes,12,opt,name=properties,proto3" json:"properties,omitempty"`
}

func (m *Column) Reset()                    { *m = Column{} }
func (m *Column) String() string            { return proto.CompactTextString(m) }
func (*Column) ProtoMessage()               {}
func (*Column) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{10} }

func (m *Column) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Column) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Column) GetDataType() DataType {
	if m != nil {
		return m.DataType
	}
	return DataType_Invalid
}

func (m *Column) GetUnsigned() bool {
	if m != nil {
		return m.Unsigned
	}
	return false
}

func (m *Column) GetScale() int32 {
	if m != nil {
		return m.Scale
	}
	return 0
}

func (m *Column) GetPrecision() int32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

func (m *Column) GetNullable() bool {
	if m != nil {
		return m.Nullable
	}
	return false
}

func (m *Column) GetPrimaryKey() uint64 {
	if m != nil {
		return m.PrimaryKey
	}
	return 0
}

func (m *Column) GetOrdinal() int32 {
	if m != nil {
		return m.Ordinal
	}
	return 0
}

func (m *Column) GetIndex() bool {
	if m != nil {
		return m.Index
	}
	return false
}

func (m *Column) GetDefaultValue() []byte {
	if m != nil {
		return m.DefaultValue
	}
	return nil
}

func (m *Column) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

type Primary struct {
	ColumnName string   `protobuf:"bytes,1,opt,name=column_name,json=columnName,proto3" json:"column_name,omitempty"`
	Next       *Primary `protobuf:"bytes,2,opt,name=next" json:"next,omitempty"`
}

func (m *Primary) Reset()                    { *m = Primary{} }
func (m *Primary) String() string            { return proto.CompactTextString(m) }
func (*Primary) ProtoMessage()               {}
func (*Primary) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{11} }

func (m *Primary) GetColumnName() string {
	if m != nil {
		return m.ColumnName
	}
	return ""
}

func (m *Primary) GetNext() *Primary {
	if m != nil {
		return m.Next
	}
	return nil
}

type TableEpoch struct {
	// Conf change version, auto increment when add or remove column
	ConfVer uint64 `protobuf:"varint,1,opt,name=conf_ver,json=confVer,proto3" json:"conf_ver,omitempty"`
	// Route version, auto increment when split or merge
	Version uint64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *TableEpoch) Reset()                    { *m = TableEpoch{} }
func (m *TableEpoch) String() string            { return proto.CompactTextString(m) }
func (*TableEpoch) ProtoMessage()               {}
func (*TableEpoch) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{12} }

func (m *TableEpoch) GetConfVer() uint64 {
	if m != nil {
		return m.ConfVer
	}
	return 0
}

func (m *TableEpoch) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type Table struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	DbName string `protobuf:"bytes,2,opt,name=db_name,json=dbName,proto3" json:"db_name,omitempty"`
	DbId   uint64 `protobuf:"varint,3,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	Id     uint64 `protobuf:"varint,4,opt,name=id,proto3" json:"id,omitempty"`
	// 必须有主键
	// repeated string primary_key = 4;
	Properties string      `protobuf:"bytes,5,opt,name=properties,proto3" json:"properties,omitempty"`
	Columns    []*Column   `protobuf:"bytes,6,rep,name=columns" json:"columns,omitempty"`
	Epoch      *TableEpoch `protobuf:"bytes,7,opt,name=epoch" json:"epoch,omitempty"`
	Regxs      []*Column   `protobuf:"bytes,8,rep,name=regxs" json:"regxs,omitempty"`
	CreateTime int64       `protobuf:"varint,9,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// 默认不检查主键重复
	PkDupCheck bool `protobuf:"varint,10,opt,name=pk_dup_check,json=pkDupCheck,proto3" json:"pk_dup_check,omitempty"`
}

func (m *Table) Reset()                    { *m = Table{} }
func (m *Table) String() string            { return proto.CompactTextString(m) }
func (*Table) ProtoMessage()               {}
func (*Table) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{13} }

func (m *Table) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Table) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *Table) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *Table) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Table) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *Table) GetColumns() []*Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

func (m *Table) GetEpoch() *TableEpoch {
	if m != nil {
		return m.Epoch
	}
	return nil
}

func (m *Table) GetRegxs() []*Column {
	if m != nil {
		return m.Regxs
	}
	return nil
}

func (m *Table) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *Table) GetPkDupCheck() bool {
	if m != nil {
		return m.PkDupCheck
	}
	return false
}

type Option struct {
	// defines maximum size of a 'memdb' before flushed to
	// 'sorted table'. 'memdb' is an in-memory DB backed by an on-disk
	// unsorted journal.
	// used for levelDB now!!!!!
	MemdbSize int32 `protobuf:"varint,1,opt,name=memdb_size,json=memdbSize,proto3" json:"memdb_size,omitempty"`
}

func (m *Option) Reset()                    { *m = Option{} }
func (m *Option) String() string            { return proto.CompactTextString(m) }
func (*Option) ProtoMessage()               {}
func (*Option) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{14} }

func (m *Option) GetMemdbSize() int32 {
	if m != nil {
		return m.MemdbSize
	}
	return 0
}

type Key struct {
	Key  []byte  `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Type KeyType `protobuf:"varint,2,opt,name=type,proto3,enum=metapb.KeyType" json:"type,omitempty"`
}

func (m *Key) Reset()                    { *m = Key{} }
func (m *Key) String() string            { return proto.CompactTextString(m) }
func (*Key) ProtoMessage()               {}
func (*Key) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{15} }

func (m *Key) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Key) GetType() KeyType {
	if m != nil {
		return m.Type
	}
	return KeyType_KT_Invalid
}

// 地域
type Zone struct {
	// 区域ID
	ZoneId   uint64 `protobuf:"varint,1,opt,name=zone_id,json=zoneId,proto3" json:"zone_id,omitempty"`
	ZoneName string `protobuf:"bytes,2,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
}

func (m *Zone) Reset()                    { *m = Zone{} }
func (m *Zone) String() string            { return proto.CompactTextString(m) }
func (*Zone) ProtoMessage()               {}
func (*Zone) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{16} }

func (m *Zone) GetZoneId() uint64 {
	if m != nil {
		return m.ZoneId
	}
	return 0
}

func (m *Zone) GetZoneName() string {
	if m != nil {
		return m.ZoneName
	}
	return ""
}

// 机房
type Room struct {
	RoomId   uint64 `protobuf:"varint,1,opt,name=room_id,json=roomId,proto3" json:"room_id,omitempty"`
	RoomName string `protobuf:"bytes,2,opt,name=room_name,json=roomName,proto3" json:"room_name,omitempty"`
}

func (m *Room) Reset()                    { *m = Room{} }
func (m *Room) String() string            { return proto.CompactTextString(m) }
func (*Room) ProtoMessage()               {}
func (*Room) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{17} }

func (m *Room) GetRoomId() uint64 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *Room) GetRoomName() string {
	if m != nil {
		return m.RoomName
	}
	return ""
}

type Machine struct {
	Ip   string `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	Zone *Zone  `protobuf:"bytes,2,opt,name=zone" json:"zone,omitempty"`
	Room *Room  `protobuf:"bytes,3,opt,name=room" json:"room,omitempty"`
	// 交换机IP
	SwitchIp string `protobuf:"bytes,4,opt,name=switch_ip,json=switchIp,proto3" json:"switch_ip,omitempty"`
	// 机架ID
	FrameId uint64 `protobuf:"varint,5,opt,name=frame_id,json=frameId,proto3" json:"frame_id,omitempty"`
}

func (m *Machine) Reset()                    { *m = Machine{} }
func (m *Machine) String() string            { return proto.CompactTextString(m) }
func (*Machine) ProtoMessage()               {}
func (*Machine) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{18} }

func (m *Machine) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *Machine) GetZone() *Zone {
	if m != nil {
		return m.Zone
	}
	return nil
}

func (m *Machine) GetRoom() *Room {
	if m != nil {
		return m.Room
	}
	return nil
}

func (m *Machine) GetSwitchIp() string {
	if m != nil {
		return m.SwitchIp
	}
	return ""
}

func (m *Machine) GetFrameId() uint64 {
	if m != nil {
		return m.FrameId
	}
	return 0
}

// 机房策略
type RoomV1Policy struct {
	RoomName string `protobuf:"bytes,1,opt,name=room_name,json=roomName,proto3" json:"room_name,omitempty"`
	// 配置需要的DS数量
	DsNum int32 `protobuf:"varint,2,opt,name=ds_num,json=dsNum,proto3" json:"ds_num,omitempty"`
	// 同步策略: 1: 同步; 2: 异步
	Sync int32 `protobuf:"varint,3,opt,name=sync,proto3" json:"sync,omitempty"`
}

func (m *RoomV1Policy) Reset()                    { *m = RoomV1Policy{} }
func (m *RoomV1Policy) String() string            { return proto.CompactTextString(m) }
func (*RoomV1Policy) ProtoMessage()               {}
func (*RoomV1Policy) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{19} }

func (m *RoomV1Policy) GetRoomName() string {
	if m != nil {
		return m.RoomName
	}
	return ""
}

func (m *RoomV1Policy) GetDsNum() int32 {
	if m != nil {
		return m.DsNum
	}
	return 0
}

func (m *RoomV1Policy) GetSync() int32 {
	if m != nil {
		return m.Sync
	}
	return 0
}

// 地域策略
type ZoneV1Policy struct {
	ZoneName string          `protobuf:"bytes,1,opt,name=zone_name,json=zoneName,proto3" json:"zone_name,omitempty"`
	Master   *RoomV1Policy   `protobuf:"bytes,2,opt,name=master" json:"master,omitempty"`
	Slaves   []*RoomV1Policy `protobuf:"bytes,3,rep,name=slaves" json:"slaves,omitempty"`
}

func (m *ZoneV1Policy) Reset()                    { *m = ZoneV1Policy{} }
func (m *ZoneV1Policy) String() string            { return proto.CompactTextString(m) }
func (*ZoneV1Policy) ProtoMessage()               {}
func (*ZoneV1Policy) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{20} }

func (m *ZoneV1Policy) GetZoneName() string {
	if m != nil {
		return m.ZoneName
	}
	return ""
}

func (m *ZoneV1Policy) GetMaster() *RoomV1Policy {
	if m != nil {
		return m.Master
	}
	return nil
}

func (m *ZoneV1Policy) GetSlaves() []*RoomV1Policy {
	if m != nil {
		return m.Slaves
	}
	return nil
}

// 部署策略
type DeployV1Policy struct {
	// 主地域
	Master *ZoneV1Policy `protobuf:"bytes,1,opt,name=master" json:"master,omitempty"`
	// 副地域(一般用于异步备份)
	Slaves []*ZoneV1Policy `protobuf:"bytes,2,rep,name=slaves" json:"slaves,omitempty"`
}

func (m *DeployV1Policy) Reset()                    { *m = DeployV1Policy{} }
func (m *DeployV1Policy) String() string            { return proto.CompactTextString(m) }
func (*DeployV1Policy) ProtoMessage()               {}
func (*DeployV1Policy) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{21} }

func (m *DeployV1Policy) GetMaster() *ZoneV1Policy {
	if m != nil {
		return m.Master
	}
	return nil
}

func (m *DeployV1Policy) GetSlaves() []*ZoneV1Policy {
	if m != nil {
		return m.Slaves
	}
	return nil
}

type TableRwPolicy struct {
	Policy       RwPolicy         `protobuf:"varint,1,opt,name=policy,proto3,enum=metapb.RwPolicy" json:"policy,omitempty"`
	RwSplit      *TableRwSplit    `protobuf:"bytes,2,opt,name=rw_split,json=rwSplit" json:"rw_split,omitempty"`
	RwMutliRead  *TableMutliRead  `protobuf:"bytes,3,opt,name=rw_mutli_read,json=rwMutliRead" json:"rw_mutli_read,omitempty"`
	RwOnlyMaster *TableOnlyMaster `protobuf:"bytes,4,opt,name=rw_only_master,json=rwOnlyMaster" json:"rw_only_master,omitempty"`
}

func (m *TableRwPolicy) Reset()                    { *m = TableRwPolicy{} }
func (m *TableRwPolicy) String() string            { return proto.CompactTextString(m) }
func (*TableRwPolicy) ProtoMessage()               {}
func (*TableRwPolicy) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{22} }

func (m *TableRwPolicy) GetPolicy() RwPolicy {
	if m != nil {
		return m.Policy
	}
	return RwPolicy_RW_Invalid
}

func (m *TableRwPolicy) GetRwSplit() *TableRwSplit {
	if m != nil {
		return m.RwSplit
	}
	return nil
}

func (m *TableRwPolicy) GetRwMutliRead() *TableMutliRead {
	if m != nil {
		return m.RwMutliRead
	}
	return nil
}

func (m *TableRwPolicy) GetRwOnlyMaster() *TableOnlyMaster {
	if m != nil {
		return m.RwOnlyMaster
	}
	return nil
}

type TableRwSplit struct {
}

func (m *TableRwSplit) Reset()                    { *m = TableRwSplit{} }
func (m *TableRwSplit) String() string            { return proto.CompactTextString(m) }
func (*TableRwSplit) ProtoMessage()               {}
func (*TableRwSplit) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{23} }

type TableMutliRead struct {
	// 最大允许的副本日志落后条目数
	ReplicaAllowMaxBackward uint32 `protobuf:"varint,1,opt,name=replica_allow_max_backward,json=replicaAllowMaxBackward,proto3" json:"replica_allow_max_backward,omitempty"`
}

func (m *TableMutliRead) Reset()                    { *m = TableMutliRead{} }
func (m *TableMutliRead) String() string            { return proto.CompactTextString(m) }
func (*TableMutliRead) ProtoMessage()               {}
func (*TableMutliRead) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{24} }

func (m *TableMutliRead) GetReplicaAllowMaxBackward() uint32 {
	if m != nil {
		return m.ReplicaAllowMaxBackward
	}
	return 0
}

type TableOnlyMaster struct {
}

func (m *TableOnlyMaster) Reset()                    { *m = TableOnlyMaster{} }
func (m *TableOnlyMaster) String() string            { return proto.CompactTextString(m) }
func (*TableOnlyMaster) ProtoMessage()               {}
func (*TableOnlyMaster) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{25} }

type TopologyEpoch struct {
	DbId     uint64         `protobuf:"varint,1,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId  uint64         `protobuf:"varint,2,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	Routes   []*Route       `protobuf:"bytes,3,rep,name=routes" json:"routes,omitempty"`
	Epoch    *TableEpoch    `protobuf:"bytes,4,opt,name=epoch" json:"epoch,omitempty"`
	RwPolicy *TableRwPolicy `protobuf:"bytes,5,opt,name=rw_policy,json=rwPolicy" json:"rw_policy,omitempty"`
}

func (m *TopologyEpoch) Reset()                    { *m = TopologyEpoch{} }
func (m *TopologyEpoch) String() string            { return proto.CompactTextString(m) }
func (*TopologyEpoch) ProtoMessage()               {}
func (*TopologyEpoch) Descriptor() ([]byte, []int) { return fileDescriptorMetapb, []int{26} }

func (m *TopologyEpoch) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *TopologyEpoch) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *TopologyEpoch) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *TopologyEpoch) GetEpoch() *TableEpoch {
	if m != nil {
		return m.Epoch
	}
	return nil
}

func (m *TopologyEpoch) GetRwPolicy() *TableRwPolicy {
	if m != nil {
		return m.RwPolicy
	}
	return nil
}

func init() {
	proto.RegisterType((*Cluster)(nil), "metapb.Cluster")
	proto.RegisterType((*RaftAddrs)(nil), "metapb.RaftAddrs")
	proto.RegisterType((*Node)(nil), "metapb.Node")
	proto.RegisterType((*Peer)(nil), "metapb.Peer")
	proto.RegisterType((*RangeEpoch)(nil), "metapb.RangeEpoch")
	proto.RegisterType((*Range)(nil), "metapb.Range")
	proto.RegisterType((*Leader)(nil), "metapb.Leader")
	proto.RegisterType((*Replica)(nil), "metapb.Replica")
	proto.RegisterType((*Route)(nil), "metapb.Route")
	proto.RegisterType((*DataBase)(nil), "metapb.DataBase")
	proto.RegisterType((*Column)(nil), "metapb.Column")
	proto.RegisterType((*Primary)(nil), "metapb.Primary")
	proto.RegisterType((*TableEpoch)(nil), "metapb.TableEpoch")
	proto.RegisterType((*Table)(nil), "metapb.Table")
	proto.RegisterType((*Option)(nil), "metapb.Option")
	proto.RegisterType((*Key)(nil), "metapb.Key")
	proto.RegisterType((*Zone)(nil), "metapb.Zone")
	proto.RegisterType((*Room)(nil), "metapb.Room")
	proto.RegisterType((*Machine)(nil), "metapb.Machine")
	proto.RegisterType((*RoomV1Policy)(nil), "metapb.RoomV1Policy")
	proto.RegisterType((*ZoneV1Policy)(nil), "metapb.ZoneV1Policy")
	proto.RegisterType((*DeployV1Policy)(nil), "metapb.DeployV1Policy")
	proto.RegisterType((*TableRwPolicy)(nil), "metapb.TableRwPolicy")
	proto.RegisterType((*TableRwSplit)(nil), "metapb.TableRwSplit")
	proto.RegisterType((*TableMutliRead)(nil), "metapb.TableMutliRead")
	proto.RegisterType((*TableOnlyMaster)(nil), "metapb.TableOnlyMaster")
	proto.RegisterType((*TopologyEpoch)(nil), "metapb.TopologyEpoch")
	proto.RegisterEnum("metapb.NodeState", NodeState_name, NodeState_value)
	proto.RegisterEnum("metapb.RangeState", RangeState_name, RangeState_value)
	proto.RegisterEnum("metapb.DataType", DataType_name, DataType_value)
	proto.RegisterEnum("metapb.KeyType", KeyType_name, KeyType_value)
	proto.RegisterEnum("metapb.RwPolicy", RwPolicy_name, RwPolicy_value)
}
func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if m.MaxPeerCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.MaxPeerCount))
	}
	return i, nil
}

func (m *RaftAddrs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftAddrs) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HeartbeatAddr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.HeartbeatAddr)))
		i += copy(dAtA[i:], m.HeartbeatAddr)
	}
	if len(m.ReplicateAddr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.ReplicateAddr)))
		i += copy(dAtA[i:], m.ReplicateAddr)
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if m.State != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.State))
	}
	if m.RaftAddrs != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RaftAddrs.Size()))
		n1, err := m.RaftAddrs.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	return i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if m.NodeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.NodeId))
	}
	return i, nil
}

func (m *RangeEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfVer != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ConfVer))
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if m.StartKey != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.StartKey.Size()))
		n2, err := m.StartKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.EndKey != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.EndKey.Size()))
		n3, err := m.EndKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.RangeEpoch != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RangeEpoch.Size()))
		n4, err := m.RangeEpoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Peers) > 0 {
		for _, msg := range m.Peers {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.State != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.State))
	}
	if m.DbId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DbId))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.TableId))
	}
	if len(m.DbName) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.DbName)))
		i += copy(dAtA[i:], m.DbName)
	}
	if len(m.TableName) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.TableName)))
		i += copy(dAtA[i:], m.TableName)
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.CreateTime))
	}
	return i, nil
}

func (m *Leader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Leader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RangeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RangeId))
	}
	if m.NodeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.NodeId))
	}
	if len(m.NodeAddr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.NodeAddr)))
		i += copy(dAtA[i:], m.NodeAddr)
	}
	return i, nil
}

func (m *Replica) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Replica) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.NodeId))
	}
	if len(m.NodeAddr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.NodeAddr)))
		i += copy(dAtA[i:], m.NodeAddr)
	}
	if m.LogIndex != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.LogIndex))
	}
	return i, nil
}

func (m *Route) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Route) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if m.StartKey != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.StartKey.Size()))
		n5, err := m.StartKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.EndKey != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.EndKey.Size()))
		n6, err := m.EndKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.RangeEpoch != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RangeEpoch.Size()))
		n7, err := m.RangeEpoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Leader != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Leader.Size()))
		n8, err := m.Leader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Replicas) > 0 {
		for _, msg := range m.Replicas {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DataBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataBase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if len(m.Properties) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Properties)))
		i += copy(dAtA[i:], m.Properties)
	}
	if m.Version != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Version))
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.CreateTime))
	}
	return i, nil
}

func (m *Column) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Column) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if m.DataType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DataType))
	}
	if m.Unsigned {
		dAtA[i] = 0x20
		i++
		if m.Unsigned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Scale != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Scale))
	}
	if m.Precision != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Precision))
	}
	if m.Nullable {
		dAtA[i] = 0x38
		i++
		if m.Nullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PrimaryKey != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.PrimaryKey))
	}
	if m.Ordinal != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Ordinal))
	}
	if m.Index {
		dAtA[i] = 0x50
		i++
		if m.Index {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.DefaultValue) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.DefaultValue)))
		i += copy(dAtA[i:], m.DefaultValue)
	}
	if len(m.Properties) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Properties)))
		i += copy(dAtA[i:], m.Properties)
	}
	return i, nil
}

func (m *Primary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Primary) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ColumnName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.ColumnName)))
		i += copy(dAtA[i:], m.ColumnName)
	}
	if m.Next != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Next.Size()))
		n9, err := m.Next.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *TableEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfVer != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ConfVer))
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Table) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.DbName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.DbName)))
		i += copy(dAtA[i:], m.DbName)
	}
	if m.DbId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DbId))
	}
	if m.Id != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Id))
	}
	if len(m.Properties) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Properties)))
		i += copy(dAtA[i:], m.Properties)
	}
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Epoch != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Epoch.Size()))
		n10, err := m.Epoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if len(m.Regxs) > 0 {
		for _, msg := range m.Regxs {
			dAtA[i] = 0x42
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CreateTime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.CreateTime))
	}
	if m.PkDupCheck {
		dAtA[i] = 0x50
		i++
		if m.PkDupCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Option) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Option) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemdbSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.MemdbSize))
	}
	return i, nil
}

func (m *Key) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Key) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *Zone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Zone) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ZoneId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ZoneId))
	}
	if len(m.ZoneName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.ZoneName)))
		i += copy(dAtA[i:], m.ZoneName)
	}
	return i, nil
}

func (m *Room) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Room) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RoomId))
	}
	if len(m.RoomName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.RoomName)))
		i += copy(dAtA[i:], m.RoomName)
	}
	return i, nil
}

func (m *Machine) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Machine) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ip) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if m.Zone != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Zone.Size()))
		n11, err := m.Zone.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Room != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Room.Size()))
		n12, err := m.Room.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.SwitchIp) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.SwitchIp)))
		i += copy(dAtA[i:], m.SwitchIp)
	}
	if m.FrameId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.FrameId))
	}
	return i, nil
}

func (m *RoomV1Policy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoomV1Policy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RoomName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.RoomName)))
		i += copy(dAtA[i:], m.RoomName)
	}
	if m.DsNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DsNum))
	}
	if m.Sync != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Sync))
	}
	return i, nil
}

func (m *ZoneV1Policy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZoneV1Policy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ZoneName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.ZoneName)))
		i += copy(dAtA[i:], m.ZoneName)
	}
	if m.Master != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Master.Size()))
		n13, err := m.Master.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Slaves) > 0 {
		for _, msg := range m.Slaves {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DeployV1Policy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeployV1Policy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Master != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Master.Size()))
		n14, err := m.Master.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Slaves) > 0 {
		for _, msg := range m.Slaves {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TableRwPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableRwPolicy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Policy != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Policy))
	}
	if m.RwSplit != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RwSplit.Size()))
		n15, err := m.RwSplit.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.RwMutliRead != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RwMutliRead.Size()))
		n16, err := m.RwMutliRead.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.RwOnlyMaster != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RwOnlyMaster.Size()))
		n17, err := m.RwOnlyMaster.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *TableRwSplit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableRwSplit) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TableMutliRead) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableMutliRead) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReplicaAllowMaxBackward != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ReplicaAllowMaxBackward))
	}
	return i, nil
}

func (m *TableOnlyMaster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableOnlyMaster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TopologyEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopologyEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DbId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DbId))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.TableId))
	}
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Epoch != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Epoch.Size()))
		n18, err := m.Epoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.RwPolicy != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.RwPolicy.Size()))
		n19, err := m.RwPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func encodeFixed64Metapb(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Metapb(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMetapb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	if m.MaxPeerCount != 0 {
		n += 1 + sovMetapb(uint64(m.MaxPeerCount))
	}
	return n
}

func (m *RaftAddrs) Size() (n int) {
	var l int
	_ = l
	l = len(m.HeartbeatAddr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.ReplicateAddr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMetapb(uint64(m.State))
	}
	if m.RaftAddrs != nil {
		l = m.RaftAddrs.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *Peer) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	if m.NodeId != 0 {
		n += 1 + sovMetapb(uint64(m.NodeId))
	}
	return n
}

func (m *RangeEpoch) Size() (n int) {
	var l int
	_ = l
	if m.ConfVer != 0 {
		n += 1 + sovMetapb(uint64(m.ConfVer))
	}
	if m.Version != 0 {
		n += 1 + sovMetapb(uint64(m.Version))
	}
	return n
}

func (m *Range) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	if m.StartKey != nil {
		l = m.StartKey.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.EndKey != nil {
		l = m.EndKey.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.RangeEpoch != nil {
		l = m.RangeEpoch.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.State != 0 {
		n += 1 + sovMetapb(uint64(m.State))
	}
	if m.DbId != 0 {
		n += 1 + sovMetapb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovMetapb(uint64(m.TableId))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.CreateTime != 0 {
		n += 1 + sovMetapb(uint64(m.CreateTime))
	}
	return n
}

func (m *Leader) Size() (n int) {
	var l int
	_ = l
	if m.RangeId != 0 {
		n += 1 + sovMetapb(uint64(m.RangeId))
	}
	if m.NodeId != 0 {
		n += 1 + sovMetapb(uint64(m.NodeId))
	}
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *Replica) Size() (n int) {
	var l int
	_ = l
	if m.NodeId != 0 {
		n += 1 + sovMetapb(uint64(m.NodeId))
	}
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.LogIndex != 0 {
		n += 1 + sovMetapb(uint64(m.LogIndex))
	}
	return n
}

func (m *Route) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	if m.StartKey != nil {
		l = m.StartKey.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.EndKey != nil {
		l = m.EndKey.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.RangeEpoch != nil {
		l = m.RangeEpoch.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	return n
}

func (m *DataBase) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	l = len(m.Properties)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovMetapb(uint64(m.Version))
	}
	if m.CreateTime != 0 {
		n += 1 + sovMetapb(uint64(m.CreateTime))
	}
	return n
}

func (m *Column) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	if m.DataType != 0 {
		n += 1 + sovMetapb(uint64(m.DataType))
	}
	if m.Unsigned {
		n += 2
	}
	if m.Scale != 0 {
		n += 1 + sovMetapb(uint64(m.Scale))
	}
	if m.Precision != 0 {
		n += 1 + sovMetapb(uint64(m.Precision))
	}
	if m.Nullable {
		n += 2
	}
	if m.PrimaryKey != 0 {
		n += 1 + sovMetapb(uint64(m.PrimaryKey))
	}
	if m.Ordinal != 0 {
		n += 1 + sovMetapb(uint64(m.Ordinal))
	}
	if m.Index {
		n += 2
	}
	l = len(m.DefaultValue)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.Properties)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *Primary) Size() (n int) {
	var l int
	_ = l
	l = len(m.ColumnName)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Next != nil {
		l = m.Next.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *TableEpoch) Size() (n int) {
	var l int
	_ = l
	if m.ConfVer != 0 {
		n += 1 + sovMetapb(uint64(m.ConfVer))
	}
	if m.Version != 0 {
		n += 1 + sovMetapb(uint64(m.Version))
	}
	return n
}

func (m *Table) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.DbId != 0 {
		n += 1 + sovMetapb(uint64(m.DbId))
	}
	if m.Id != 0 {
		n += 1 + sovMetapb(uint64(m.Id))
	}
	l = len(m.Properties)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.Epoch != nil {
		l = m.Epoch.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Regxs) > 0 {
		for _, e := range m.Regxs {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.CreateTime != 0 {
		n += 1 + sovMetapb(uint64(m.CreateTime))
	}
	if m.PkDupCheck {
		n += 2
	}
	return n
}

func (m *Option) Size() (n int) {
	var l int
	_ = l
	if m.MemdbSize != 0 {
		n += 1 + sovMetapb(uint64(m.MemdbSize))
	}
	return n
}

func (m *Key) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMetapb(uint64(m.Type))
	}
	return n
}

func (m *Zone) Size() (n int) {
	var l int
	_ = l
	if m.ZoneId != 0 {
		n += 1 + sovMetapb(uint64(m.ZoneId))
	}
	l = len(m.ZoneName)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *Room) Size() (n int) {
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovMetapb(uint64(m.RoomId))
	}
	l = len(m.RoomName)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *Machine) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Zone != nil {
		l = m.Zone.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Room != nil {
		l = m.Room.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.SwitchIp)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.FrameId != 0 {
		n += 1 + sovMetapb(uint64(m.FrameId))
	}
	return n
}

func (m *RoomV1Policy) Size() (n int) {
	var l int
	_ = l
	l = len(m.RoomName)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.DsNum != 0 {
		n += 1 + sovMetapb(uint64(m.DsNum))
	}
	if m.Sync != 0 {
		n += 1 + sovMetapb(uint64(m.Sync))
	}
	return n
}

func (m *ZoneV1Policy) Size() (n int) {
	var l int
	_ = l
	l = len(m.ZoneName)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Master != nil {
		l = m.Master.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Slaves) > 0 {
		for _, e := range m.Slaves {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	return n
}

func (m *DeployV1Policy) Size() (n int) {
	var l int
	_ = l
	if m.Master != nil {
		l = m.Master.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Slaves) > 0 {
		for _, e := range m.Slaves {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	return n
}

func (m *TableRwPolicy) Size() (n int) {
	var l int
	_ = l
	if m.Policy != 0 {
		n += 1 + sovMetapb(uint64(m.Policy))
	}
	if m.RwSplit != nil {
		l = m.RwSplit.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.RwMutliRead != nil {
		l = m.RwMutliRead.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.RwOnlyMaster != nil {
		l = m.RwOnlyMaster.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *TableRwSplit) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TableMutliRead) Size() (n int) {
	var l int
	_ = l
	if m.ReplicaAllowMaxBackward != 0 {
		n += 1 + sovMetapb(uint64(m.ReplicaAllowMaxBackward))
	}
	return n
}

func (m *TableOnlyMaster) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TopologyEpoch) Size() (n int) {
	var l int
	_ = l
	if m.DbId != 0 {
		n += 1 + sovMetapb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovMetapb(uint64(m.TableId))
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.Epoch != nil {
		l = m.Epoch.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.RwPolicy != nil {
		l = m.RwPolicy.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func sovMetapb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMetapb(x uint64) (n int) {
	return sovMetapb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPeerCount", wireType)
			}
			m.MaxPeerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPeerCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftAddrs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftAddrs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftAddrs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeartbeatAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicateAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicateAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (NodeState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAddrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RaftAddrs == nil {
				m.RaftAddrs = &RaftAddrs{}
			}
			if err := m.RaftAddrs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfVer", wireType)
			}
			m.ConfVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfVer |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartKey == nil {
				m.StartKey = &Key{}
			}
			if err := m.StartKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndKey == nil {
				m.EndKey = &Key{}
			}
			if err := m.EndKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeEpoch == nil {
				m.RangeEpoch = &RangeEpoch{}
			}
			if err := m.RangeEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &Peer{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (RangeState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Leader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Leader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Leader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Replica) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogIndex", wireType)
			}
			m.LogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartKey == nil {
				m.StartKey = &Key{}
			}
			if err := m.StartKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndKey == nil {
				m.EndKey = &Key{}
			}
			if err := m.EndKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RangeEpoch == nil {
				m.RangeEpoch = &RangeEpoch{}
			}
			if err := m.RangeEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &Leader{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, &Replica{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Column) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Column: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Column: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataType", wireType)
			}
			m.DataType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataType |= (DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unsigned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unsigned = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
			m.PrimaryKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrimaryKey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Index = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultValue = append(m.DefaultValue[:0], dAtA[iNdEx:postIndex]...)
			if m.DefaultValue == nil {
				m.DefaultValue = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Primary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Primary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Primary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColumnName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &Primary{}
			}
			if err := m.Next.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfVer", wireType)
			}
			m.ConfVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfVer |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Properties = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Epoch == nil {
				m.Epoch = &TableEpoch{}
			}
			if err := m.Epoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regxs = append(m.Regxs, &Column{})
			if err := m.Regxs[len(m.Regxs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkDupCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PkDupCheck = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Option) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Option: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Option: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemdbSize", wireType)
			}
			m.MemdbSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemdbSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Key) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Key: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Key: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (KeyType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Zone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Zone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Zone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneId", wireType)
			}
			m.ZoneId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZoneId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZoneName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Room) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Room: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Room: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Machine) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Machine: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Machine: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zone == nil {
				m.Zone = &Zone{}
			}
			if err := m.Zone.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Room", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Room == nil {
				m.Room = &Room{}
			}
			if err := m.Room.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwitchIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrameId", wireType)
			}
			m.FrameId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrameId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoomV1Policy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoomV1Policy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoomV1Policy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoomName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DsNum", wireType)
			}
			m.DsNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DsNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sync", wireType)
			}
			m.Sync = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sync |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZoneV1Policy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZoneV1Policy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZoneV1Policy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZoneName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Master == nil {
				m.Master = &RoomV1Policy{}
			}
			if err := m.Master.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slaves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Slaves = append(m.Slaves, &RoomV1Policy{})
			if err := m.Slaves[len(m.Slaves)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeployV1Policy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeployV1Policy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeployV1Policy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Master == nil {
				m.Master = &ZoneV1Policy{}
			}
			if err := m.Master.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slaves", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Slaves = append(m.Slaves, &ZoneV1Policy{})
			if err := m.Slaves[len(m.Slaves)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableRwPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableRwPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableRwPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= (RwPolicy(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RwSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RwSplit == nil {
				m.RwSplit = &TableRwSplit{}
			}
			if err := m.RwSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RwMutliRead", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RwMutliRead == nil {
				m.RwMutliRead = &TableMutliRead{}
			}
			if err := m.RwMutliRead.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RwOnlyMaster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RwOnlyMaster == nil {
				m.RwOnlyMaster = &TableOnlyMaster{}
			}
			if err := m.RwOnlyMaster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableRwSplit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableRwSplit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableRwSplit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableMutliRead) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableMutliRead: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableMutliRead: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaAllowMaxBackward", wireType)
			}
			m.ReplicaAllowMaxBackward = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaAllowMaxBackward |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableOnlyMaster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableOnlyMaster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableOnlyMaster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopologyEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopologyEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopologyEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Epoch == nil {
				m.Epoch = &TableEpoch{}
			}
			if err := m.Epoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RwPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RwPolicy == nil {
				m.RwPolicy = &TableRwPolicy{}
			}
			if err := m.RwPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetapb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMetapb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMetapb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMetapb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetapb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("metapb.proto", fileDescriptorMetapb) }

var fileDescriptorMetapb = []byte{
	// 1782 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xdd, 0x6e, 0xe4, 0x48,
	0x15, 0x5e, 0xbb, 0xdb, 0x3f, 0x7d, 0xfa, 0x67, 0xbc, 0xb5, 0xb3, 0x4c, 0x33, 0xb0, 0x21, 0xf2,
	0xce, 0xb2, 0xad, 0x00, 0x3b, 0x90, 0xbd, 0x83, 0x45, 0x68, 0x66, 0x02, 0x52, 0x2b, 0x93, 0x64,
	0x54, 0x09, 0x19, 0x2d, 0x5a, 0xc9, 0xaa, 0x6e, 0x57, 0x3a, 0x56, 0x6c, 0x97, 0x29, 0xbb, 0xd3,
	0xe9, 0x79, 0x01, 0x84, 0xc4, 0x05, 0x37, 0x48, 0xbc, 0x00, 0xaf, 0xc0, 0x13, 0x70, 0xc1, 0x25,
	0x2f, 0x80, 0x84, 0x06, 0xf1, 0x00, 0x88, 0x17, 0x40, 0xa7, 0xaa, 0xda, 0x6d, 0x27, 0x13, 0x81,
	0xc4, 0x0d, 0x77, 0x75, 0x7e, 0xea, 0xfc, 0x7e, 0xe7, 0xb8, 0x0c, 0x83, 0x8c, 0x57, 0xac, 0x98,
	0x7d, 0x56, 0x48, 0x51, 0x09, 0xe2, 0x6a, 0xea, 0xf1, 0xc3, 0x85, 0x58, 0x08, 0xc5, 0x7a, 0x8a,
	0x27, 0x2d, 0x0d, 0x7f, 0x02, 0xde, 0x8b, 0x74, 0x59, 0x56, 0x5c, 0x92, 0x11, 0xd8, 0x49, 0x3c,
	0xb6, 0x76, 0xad, 0x49, 0x97, 0xda, 0x49, 0x4c, 0x9e, 0xc0, 0x28, 0x63, 0x37, 0x51, 0xc1, 0xb9,
	0x8c, 0xe6, 0x62, 0x99, 0x57, 0x63, 0x7b, 0xd7, 0x9a, 0x0c, 0xe9, 0x20, 0x63, 0x37, 0xaf, 0x38,
	0x97, 0x2f, 0x90, 0x17, 0x7e, 0x09, 0x3d, 0xca, 0x2e, 0xaa, 0x67, 0x71, 0x2c, 0x4b, 0xf2, 0x09,
	0x8c, 0x2e, 0x39, 0x93, 0xd5, 0x8c, 0xb3, 0x2a, 0x62, 0x71, 0x2c, 0x95, 0xb9, 0x1e, 0x1d, 0xd6,
	0x5c, 0xd4, 0x43, 0x35, 0xc9, 0x8b, 0x34, 0x99, 0xb3, 0x8a, 0x6b, 0x35, 0x5b, 0xab, 0xd5, 0x5c,
	0x54, 0x0b, 0xff, 0x60, 0x41, 0xf7, 0x58, 0xc4, 0xfc, 0x4e, 0x64, 0x63, 0xf0, 0xf0, 0x16, 0x2f,
	0x4b, 0x73, 0x71, 0x43, 0x92, 0x4f, 0xc1, 0x29, 0x2b, 0x56, 0xf1, 0x71, 0x67, 0xd7, 0x9a, 0x8c,
	0xf6, 0xdf, 0xff, 0xcc, 0x94, 0x02, 0xcd, 0x9c, 0xa2, 0x80, 0x6a, 0x39, 0xf9, 0x3e, 0x80, 0x64,
	0x17, 0x3a, 0xc8, 0x72, 0xdc, 0xdd, 0xb5, 0x26, 0xfd, 0xad, 0x76, 0x9d, 0x10, 0xed, 0xc9, 0x3a,
	0xb7, 0x31, 0x78, 0xd7, 0x5c, 0x96, 0x89, 0xc8, 0xc7, 0x8e, 0x76, 0x6a, 0xc8, 0xf0, 0x29, 0x74,
	0xb1, 0x1e, 0x77, 0xc2, 0x7c, 0x04, 0x5e, 0x2e, 0x62, 0x1e, 0x25, 0xb1, 0x0a, 0xb3, 0x4b, 0x5d,
	0x24, 0xa7, 0x71, 0xf8, 0x0c, 0x80, 0xb2, 0x7c, 0xc1, 0x7f, 0x5a, 0x88, 0xf9, 0x25, 0xf9, 0x3a,
	0xf8, 0x73, 0x91, 0x5f, 0x44, 0xd7, 0x5c, 0x9a, 0xcb, 0x1e, 0xd2, 0xe7, 0x5c, 0x36, 0x7d, 0x6a,
	0x0b, 0xb5, 0xcf, 0x7f, 0xd9, 0xe0, 0x28, 0x1b, 0x77, 0xbc, 0x4e, 0xa0, 0x57, 0x56, 0x4c, 0x56,
	0xd1, 0x15, 0x5f, 0xab, 0x5b, 0xfd, 0xfd, 0xfe, 0x26, 0xb1, 0x43, 0xbe, 0xa6, 0xbe, 0x92, 0x1e,
	0xf2, 0x35, 0x79, 0x02, 0x1e, 0xcf, 0x63, 0xa5, 0xd7, 0xb9, 0xab, 0xe7, 0xf2, 0x3c, 0x46, 0xad,
	0xcf, 0xa1, 0x2f, 0xd1, 0x51, 0xc4, 0x31, 0x5a, 0x53, 0x2a, 0xb2, 0x2d, 0xd5, 0x26, 0x0f, 0x0a,
	0x72, 0x9b, 0x53, 0x08, 0x0e, 0xe2, 0xa6, 0x1c, 0x3b, 0xbb, 0x9d, 0x49, 0x7f, 0x7f, 0xb0, 0x51,
	0xc7, 0x3a, 0x51, 0x2d, 0x22, 0x93, 0x4d, 0xaf, 0x5c, 0xd5, 0xab, 0xb6, 0xc9, 0x56, 0xb3, 0x3e,
	0x00, 0x27, 0x9e, 0x61, 0x19, 0x3d, 0x95, 0x65, 0x37, 0x9e, 0x4d, 0x63, 0x2c, 0x5b, 0xc5, 0x66,
	0xa9, 0x2a, 0xaf, 0xaf, 0x8b, 0xa3, 0xe8, 0xa9, 0x2a, 0x7c, 0x3c, 0x8b, 0x72, 0x96, 0xf1, 0x71,
	0x4f, 0xb5, 0xca, 0x8d, 0x67, 0xc7, 0x2c, 0xe3, 0xe4, 0x23, 0x00, 0x7d, 0x47, 0xc9, 0x40, 0xc9,
	0x7a, 0x8a, 0xa3, 0xc4, 0xdf, 0x82, 0xfe, 0x5c, 0x72, 0x04, 0x65, 0x95, 0x64, 0x7c, 0xdc, 0xdf,
	0xb5, 0x26, 0x1d, 0x0a, 0x9a, 0x75, 0x96, 0x64, 0x3c, 0xfc, 0x12, 0xdc, 0x97, 0x9c, 0xc5, 0x5c,
	0xa2, 0x77, 0x5d, 0x95, 0xba, 0xf6, 0x9e, 0xa2, 0xa7, 0xf7, 0xb7, 0x9d, 0x7c, 0x03, 0x7a, 0x4a,
	0xa0, 0x10, 0xdf, 0x51, 0xce, 0x7d, 0x64, 0x28, 0xb0, 0x7f, 0x05, 0x1e, 0xd5, 0xe8, 0x6f, 0x1a,
	0xb0, 0xee, 0x37, 0x60, 0xb7, 0x0d, 0xa0, 0x30, 0x15, 0x8b, 0x28, 0xc9, 0x63, 0x7e, 0xa3, 0xac,
	0x77, 0xa9, 0x9f, 0x8a, 0xc5, 0x14, 0xe9, 0xf0, 0x9f, 0x16, 0x38, 0x54, 0x2c, 0xab, 0xff, 0x53,
	0xb8, 0x7c, 0x1b, 0xdc, 0x54, 0xd5, 0x55, 0x8d, 0x56, 0x7f, 0x7f, 0xb4, 0xd1, 0xd7, 0xd5, 0xa6,
	0x46, 0x4a, 0xbe, 0x03, 0xbe, 0x59, 0x11, 0xe5, 0xd8, 0x55, 0xc8, 0x7a, 0x50, 0x5b, 0xd6, 0x7c,
	0x5a, 0x2b, 0x84, 0xbf, 0xb6, 0xc0, 0x3f, 0x60, 0x15, 0x7b, 0xce, 0x4a, 0x4e, 0x08, 0x74, 0x55,
	0xcf, 0xf5, 0x3e, 0x52, 0x67, 0x53, 0x0a, 0xbb, 0x2e, 0xc5, 0x0e, 0x40, 0x21, 0x45, 0xc1, 0x65,
	0x95, 0xf0, 0xd2, 0x34, 0xa8, 0xc1, 0x69, 0x4e, 0x63, 0xb7, 0x35, 0x8d, 0xb7, 0x81, 0xe3, 0xdc,
	0x01, 0xce, 0x5f, 0x6d, 0x70, 0x5f, 0x88, 0x74, 0x99, 0xe5, 0xff, 0x55, 0x24, 0xdf, 0x83, 0x5e,
	0xcc, 0x2a, 0x16, 0x55, 0xeb, 0x62, 0xb3, 0xca, 0x82, 0x4d, 0xa2, 0x98, 0xd2, 0xd9, 0xba, 0xe0,
	0xd4, 0x8f, 0xcd, 0x89, 0x3c, 0x06, 0x7f, 0x99, 0x97, 0xc9, 0x22, 0xe7, 0xb1, 0x8a, 0xcc, 0xa7,
	0x35, 0x4d, 0x1e, 0x82, 0x53, 0xce, 0x59, 0xaa, 0x83, 0x72, 0xa8, 0x26, 0xc8, 0x37, 0xa1, 0x57,
	0x48, 0x3e, 0x4f, 0x54, 0x32, 0xae, 0x92, 0x6c, 0x19, 0x68, 0x2f, 0x5f, 0xa6, 0x29, 0xce, 0x85,
	0x1a, 0x39, 0x9f, 0xd6, 0x34, 0xa6, 0x5a, 0xc8, 0x24, 0x63, 0x72, 0xad, 0x90, 0xa0, 0x27, 0x0f,
	0x0c, 0x0b, 0x01, 0x30, 0x06, 0x4f, 0xc8, 0x38, 0xc9, 0x59, 0xaa, 0x86, 0xcf, 0xa1, 0x1b, 0x12,
	0x43, 0xd1, 0xe8, 0x04, 0x65, 0x53, 0x13, 0xe4, 0x63, 0x18, 0xc6, 0xfc, 0x82, 0x2d, 0xd3, 0x2a,
	0xba, 0x66, 0xe9, 0x52, 0x8f, 0xdd, 0x80, 0x0e, 0x0c, 0xf3, 0x1c, 0x79, 0xb7, 0x5a, 0x33, 0xb8,
	0xdd, 0x9a, 0xf0, 0x04, 0xbc, 0x57, 0x3a, 0x04, 0xd5, 0x0b, 0x55, 0xe9, 0xa8, 0x51, 0x66, 0xd0,
	0x2c, 0x35, 0xe5, 0x1f, 0x43, 0x37, 0xe7, 0x37, 0x95, 0x01, 0x7b, 0x0d, 0x20, 0x73, 0x9f, 0x2a,
	0x21, 0xae, 0xe8, 0x33, 0xcc, 0xf7, 0x7f, 0x58, 0xd1, 0x7f, 0xb4, 0xc1, 0x51, 0x36, 0xde, 0xd9,
	0xf2, 0xc6, 0x8e, 0xb2, 0x5b, 0x3b, 0xaa, 0x5e, 0x76, 0x9d, 0xc6, 0xb2, 0xd3, 0x00, 0xe9, 0xde,
	0x03, 0x55, 0xe7, 0x0e, 0x54, 0x27, 0xe0, 0xe9, 0x8c, 0x37, 0x73, 0x52, 0x4f, 0x94, 0x46, 0x21,
	0xdd, 0x88, 0x71, 0x0b, 0xeb, 0x49, 0xf5, 0xda, 0x93, 0xba, 0xcd, 0x9e, 0x6a, 0x05, 0xf2, 0x04,
	0x1c, 0xc9, 0x17, 0x37, 0xe5, 0xd8, 0x7f, 0xa7, 0x45, 0x2d, 0xbc, 0x3d, 0x0a, 0xbd, 0xdb, 0xa3,
	0x40, 0x76, 0x61, 0x50, 0x5c, 0x45, 0xf1, 0xb2, 0x88, 0xe6, 0x97, 0x7c, 0x7e, 0x65, 0xc0, 0x00,
	0xc5, 0xd5, 0xc1, 0xb2, 0x78, 0x81, 0x9c, 0xf0, 0x53, 0x70, 0x4f, 0x8a, 0x0a, 0x81, 0xf8, 0x11,
	0x40, 0xc6, 0xb3, 0x78, 0x16, 0x95, 0xc9, 0x1b, 0x5d, 0x3e, 0x87, 0xf6, 0x14, 0xe7, 0x34, 0x79,
	0xc3, 0xc3, 0x2f, 0xa0, 0x83, 0x88, 0x0b, 0xa0, 0x83, 0x50, 0xb4, 0x14, 0x6e, 0xf0, 0x88, 0x2d,
	0x56, 0xa3, 0x63, 0xab, 0xd1, 0x79, 0xd0, 0xd8, 0x53, 0x6a, 0x72, 0x94, 0x30, 0xfc, 0x02, 0xba,
	0xbf, 0x10, 0xb9, 0xea, 0xc4, 0x1b, 0x91, 0x37, 0xd7, 0x2d, 0x92, 0x7a, 0xdd, 0x2a, 0x41, 0xa3,
	0x49, 0x3e, 0x32, 0xb0, 0x4d, 0x78, 0x9b, 0x0a, 0x91, 0xe1, 0x6d, 0x29, 0x44, 0xd6, 0xb8, 0x8d,
	0xa4, 0xbe, 0xad, 0x04, 0xcd, 0xdb, 0xc8, 0x50, 0xb7, 0x7f, 0x67, 0x81, 0x77, 0xc4, 0xe6, 0x97,
	0x49, 0xae, 0x87, 0xbf, 0x30, 0xd8, 0xb0, 0x93, 0x82, 0xec, 0x42, 0x17, 0xbd, 0x18, 0x7c, 0xd6,
	0x9f, 0x4e, 0x8c, 0x95, 0x2a, 0x09, 0x6a, 0xa0, 0x25, 0xb3, 0x86, 0x6b, 0x0d, 0x8c, 0x87, 0x2a,
	0x09, 0x3a, 0x2f, 0x57, 0x49, 0x35, 0xbf, 0x8c, 0x92, 0x42, 0xc1, 0xa6, 0x47, 0x7d, 0xcd, 0x98,
	0x16, 0x88, 0xe6, 0x0b, 0xc9, 0x32, 0x95, 0xb1, 0xa3, 0x31, 0xab, 0xe8, 0x69, 0x1c, 0x9e, 0xc3,
	0x00, 0xad, 0x9c, 0xff, 0xe0, 0x95, 0x48, 0x93, 0xf9, 0xba, 0x9d, 0x84, 0xd5, 0x4e, 0x82, 0x7c,
	0x08, 0x6e, 0x5c, 0x46, 0xf9, 0x32, 0x53, 0xa1, 0x3a, 0xd4, 0x89, 0xcb, 0xe3, 0x65, 0x86, 0x68,
	0x2f, 0xd7, 0xf9, 0x5c, 0x45, 0xe7, 0x50, 0x75, 0x0e, 0x7f, 0x65, 0xc1, 0x00, 0x13, 0x68, 0x1a,
	0xde, 0xd6, 0xd6, 0x6a, 0xd7, 0x96, 0x7c, 0x17, 0xdc, 0x8c, 0xe1, 0x9b, 0xd4, 0xd4, 0xe0, 0x61,
	0x33, 0xc3, 0x8d, 0x09, 0x6a, 0x74, 0x50, 0xbb, 0x4c, 0xd9, 0xb5, 0x5a, 0xd9, 0x9d, 0xfb, 0xb5,
	0xb5, 0x4e, 0x98, 0xc2, 0xe8, 0x80, 0x17, 0xa9, 0x58, 0xd7, 0xa1, 0x6c, 0xbd, 0x59, 0x6d, 0x6f,
	0xcd, 0x80, 0xdf, 0xe1, 0xcd, 0x6e, 0x7b, 0x6b, 0x6b, 0x1b, 0x6f, 0xff, 0xb0, 0x60, 0xa8, 0x26,
	0x89, 0xae, 0x8c, 0xb7, 0x09, 0xb8, 0x85, 0x3a, 0x29, 0x6f, 0x8d, 0xbd, 0xbe, 0xd1, 0xa0, 0x46,
	0x4e, 0x9e, 0x82, 0x2f, 0x57, 0x51, 0x59, 0xa4, 0x49, 0x75, 0xbb, 0x0e, 0xc6, 0xe4, 0x29, 0xca,
	0xa8, 0x27, 0xf5, 0x81, 0xfc, 0x10, 0x86, 0x72, 0x15, 0x65, 0xcb, 0x2a, 0x4d, 0x22, 0xc9, 0x59,
	0x6c, 0xf0, 0xf1, 0xb5, 0xd6, 0xad, 0x23, 0x14, 0x53, 0xce, 0x62, 0xda, 0x97, 0xab, 0x9a, 0x20,
	0x3f, 0x86, 0x91, 0x5c, 0x45, 0x22, 0x4f, 0xd7, 0x91, 0x29, 0x86, 0xfe, 0x72, 0x3f, 0x6a, 0x5d,
	0x3e, 0xc9, 0xd3, 0xf5, 0x91, 0x12, 0xd3, 0x81, 0x5c, 0x6d, 0xa9, 0x70, 0x04, 0x83, 0x66, 0x4c,
	0xe1, 0x11, 0x8c, 0xda, 0xde, 0xc8, 0x8f, 0xe0, 0xb1, 0xf9, 0x32, 0x47, 0x2c, 0x4d, 0xc5, 0x2a,
	0xc2, 0x7f, 0x8b, 0x19, 0x9b, 0x5f, 0xad, 0x98, 0xd4, 0xa3, 0x33, 0xa4, 0x8f, 0x8c, 0xc6, 0x33,
	0x54, 0x38, 0x62, 0x37, 0xcf, 0x8d, 0x38, 0x7c, 0x1f, 0x1e, 0xdc, 0xf2, 0x1f, 0xfe, 0x09, 0x2b,
	0x2b, 0x0a, 0x91, 0x8a, 0xc5, 0x5a, 0x2f, 0xe9, 0x7a, 0x71, 0x5a, 0xf7, 0xbc, 0x12, 0xed, 0xf6,
	0x2b, 0xf1, 0x13, 0x70, 0x25, 0x3e, 0x89, 0x36, 0xb8, 0x19, 0x6e, 0x71, 0xb3, 0xac, 0x38, 0x35,
	0xc2, 0xed, 0x82, 0xec, 0xfe, 0xa7, 0x05, 0xb9, 0x0f, 0x3d, 0xb9, 0x8a, 0x4c, 0x77, 0xf5, 0x43,
	0xe6, 0xc3, 0x5b, 0x1d, 0x33, 0x2d, 0xf6, 0xa5, 0x39, 0xed, 0xfd, 0x12, 0x7a, 0xf5, 0xbf, 0x09,
	0x19, 0x42, 0xef, 0x38, 0x9a, 0xe6, 0xd7, 0x2c, 0x4d, 0xe2, 0xe0, 0x3d, 0xd2, 0x07, 0xef, 0x38,
	0x7a, 0x29, 0x16, 0x49, 0x1e, 0x58, 0x64, 0x00, 0xbe, 0x22, 0xc4, 0xb2, 0x0a, 0x6c, 0x2d, 0x3a,
	0x10, 0xcb, 0x59, 0x15, 0x74, 0xc8, 0x03, 0xe8, 0x1f, 0x47, 0x67, 0x22, 0x9b, 0x95, 0x95, 0xc8,
	0x79, 0xd0, 0xd5, 0x76, 0x7e, 0x5e, 0x2c, 0x24, 0x8b, 0x79, 0xe0, 0x6c, 0xcc, 0x26, 0x55, 0xc2,
	0xd2, 0xc0, 0xdd, 0xfb, 0x8d, 0x65, 0x7e, 0x3f, 0x6a, 0xa7, 0xb4, 0xe1, 0x14, 0xc0, 0xa5, 0x4a,
	0x59, 0xfb, 0xa4, 0xd1, 0xb1, 0x90, 0x19, 0x4b, 0xb5, 0x4f, 0x1a, 0xa9, 0xf6, 0x06, 0x1d, 0x4d,
	0x1c, 0x71, 0xb9, 0x40, 0x7f, 0x4a, 0x8f, 0xf2, 0x4c, 0x5c, 0xa3, 0xbb, 0x11, 0x00, 0x8d, 0x5e,
	0x0a, 0x16, 0x9f, 0xe6, 0xac, 0x08, 0x5c, 0x4d, 0x3f, 0x9b, 0xe5, 0xda, 0x8e, 0xa7, 0x1d, 0x9e,
	0x5c, 0x5c, 0xa4, 0x49, 0xce, 0x03, 0x7f, 0xef, 0xb7, 0xe6, 0x99, 0xa6, 0x5e, 0x32, 0x7d, 0xf0,
	0x5a, 0xf9, 0x9f, 0x25, 0xf9, 0x3a, 0xc9, 0x4d, 0x2c, 0xa7, 0x19, 0x4b, 0x53, 0xa4, 0x6c, 0xe2,
	0x41, 0x67, 0x9a, 0x63, 0x1c, 0x00, 0xee, 0xf3, 0x64, 0x81, 0xe7, 0x2e, 0xe9, 0x81, 0xf3, 0xb3,
	0x54, 0xb0, 0x2a, 0x70, 0x90, 0x8d, 0xd5, 0x49, 0x79, 0xe0, 0xa2, 0x99, 0x73, 0x26, 0xe7, 0x97,
	0x4c, 0x06, 0x9e, 0xd6, 0xcf, 0x99, 0x5c, 0x07, 0x3e, 0xf1, 0xa1, 0x7b, 0xc0, 0x2a, 0x1e, 0xf4,
	0x30, 0x24, 0xfc, 0x36, 0x9d, 0x56, 0x2c, 0x2b, 0x02, 0xd8, 0xfb, 0x0a, 0x3c, 0xf3, 0xa9, 0xc0,
	0xe0, 0x0f, 0xcf, 0x1a, 0xe5, 0x79, 0x04, 0x1f, 0x1c, 0x9e, 0x45, 0xaf, 0x44, 0x99, 0x54, 0xc9,
	0x35, 0x9f, 0xe6, 0x17, 0x49, 0x9e, 0x54, 0xeb, 0xc0, 0x32, 0x82, 0x63, 0xbe, 0x60, 0x2d, 0x81,
	0x8d, 0xdd, 0x39, 0x3c, 0x8b, 0x4e, 0xd4, 0x1b, 0x48, 0xae, 0x83, 0xce, 0xde, 0x11, 0xf8, 0xf5,
	0x36, 0xc0, 0xda, 0xbc, 0x6e, 0x98, 0xc7, 0x4a, 0xbe, 0x36, 0x45, 0xb6, 0x48, 0x00, 0x03, 0xfa,
	0x3a, 0xaa, 0x67, 0x28, 0xb0, 0xc9, 0xfb, 0x30, 0xa4, 0xaf, 0xa3, 0xed, 0x18, 0x04, 0x9d, 0xe7,
	0xc1, 0x9f, 0xdf, 0xee, 0x58, 0x7f, 0x79, 0xbb, 0x63, 0xfd, 0xed, 0xed, 0x8e, 0xf5, 0xfb, 0xbf,
	0xef, 0xbc, 0x37, 0x73, 0xd5, 0xaf, 0xfd, 0xe7, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x3d, 0x9c,
	0xc8, 0x3f, 0x08, 0x10, 0x00, 0x00,
}
