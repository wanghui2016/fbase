// Code generated by protoc-gen-gogo.
// source: mspb.proto
// DO NOT EDIT!

/*
	Package mspb is a generated protocol buffer package.

	It is generated from these files:
		mspb.proto

	It has these top-level messages:
		GetTopologyEpochRequest
		GetTopologyEpochResponse
		MSLeader
		GetMSLeaderRequest
		GetMSLeaderResponse
		PeerStats
		RangeHeartbeatRequest
		RangeHeartbeatResponse
		NodeHeartbeatRequest
		NodeHeartbeatResponse
		GatewayHeartbeatRequest
		GatewayHeartbeatResponse
		ReportEventRequest
		ReportEventResponse
		GetNodeRequest
		GetNodeResponse
		GetDBRequest
		GetDBResponse
		GetTableRequest
		GetTableByIdRequest
		GetTableResponse
		GetTableByIdResponse
		GetColumnsRequest
		GetColumnsResponse
		GetColumnByNameRequest
		GetColumnByNameResponse
		GetColumnByIdRequest
		GetColumnByIdResponse
		AddColumnRequest
		AddColumnResponse
		TruncateTableRequest
		TruncateTableResponse
		RequestHeader
		ResponseHeader
		MsLeader
		NoLeader
		Error
*/
package mspb

import (
	"fmt"
	"io"
	"math"

	proto "github.com/golang/protobuf/proto"

	metapb "model/pkg/metapb"

	statspb "model/pkg/statspb"

	eventpb "model/pkg/eventpb"

	taskpb "model/pkg/taskpb"

	context "golang.org/x/net/context"

	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type GetTopologyEpochRequest struct {
	Header   *RequestHeader     `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	DbId     uint64             `protobuf:"varint,2,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId  uint64             `protobuf:"varint,3,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	CurEpoch *metapb.TableEpoch `protobuf:"bytes,4,opt,name=cur_epoch,json=curEpoch" json:"cur_epoch,omitempty"`
}

func (m *GetTopologyEpochRequest) Reset()                    { *m = GetTopologyEpochRequest{} }
func (m *GetTopologyEpochRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTopologyEpochRequest) ProtoMessage()               {}
func (*GetTopologyEpochRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{0} }

func (m *GetTopologyEpochRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetTopologyEpochRequest) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *GetTopologyEpochRequest) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *GetTopologyEpochRequest) GetCurEpoch() *metapb.TableEpoch {
	if m != nil {
		return m.CurEpoch
	}
	return nil
}

type GetTopologyEpochResponse struct {
	Header   *ResponseHeader       `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Routes   []*metapb.Route       `protobuf:"bytes,2,rep,name=routes" json:"routes,omitempty"`
	Epoch    *metapb.TableEpoch    `protobuf:"bytes,3,opt,name=epoch" json:"epoch,omitempty"`
	RwPolicy *metapb.TableRwPolicy `protobuf:"bytes,4,opt,name=rw_policy,json=rwPolicy" json:"rw_policy,omitempty"`
}

func (m *GetTopologyEpochResponse) Reset()                    { *m = GetTopologyEpochResponse{} }
func (m *GetTopologyEpochResponse) String() string            { return proto.CompactTextString(m) }
func (*GetTopologyEpochResponse) ProtoMessage()               {}
func (*GetTopologyEpochResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{1} }

func (m *GetTopologyEpochResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetTopologyEpochResponse) GetRoutes() []*metapb.Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *GetTopologyEpochResponse) GetEpoch() *metapb.TableEpoch {
	if m != nil {
		return m.Epoch
	}
	return nil
}

func (m *GetTopologyEpochResponse) GetRwPolicy() *metapb.TableRwPolicy {
	if m != nil {
		return m.RwPolicy
	}
	return nil
}

type MSLeader struct {
	Id      uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Address string `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *MSLeader) Reset()                    { *m = MSLeader{} }
func (m *MSLeader) String() string            { return proto.CompactTextString(m) }
func (*MSLeader) ProtoMessage()               {}
func (*MSLeader) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{2} }

func (m *MSLeader) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MSLeader) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type GetMSLeaderRequest struct {
	Header *RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
}

func (m *GetMSLeaderRequest) Reset()                    { *m = GetMSLeaderRequest{} }
func (m *GetMSLeaderRequest) String() string            { return proto.CompactTextString(m) }
func (*GetMSLeaderRequest) ProtoMessage()               {}
func (*GetMSLeaderRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{3} }

func (m *GetMSLeaderRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type GetMSLeaderResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Leader *MSLeader       `protobuf:"bytes,2,opt,name=leader" json:"leader,omitempty"`
}

func (m *GetMSLeaderResponse) Reset()                    { *m = GetMSLeaderResponse{} }
func (m *GetMSLeaderResponse) String() string            { return proto.CompactTextString(m) }
func (*GetMSLeaderResponse) ProtoMessage()               {}
func (*GetMSLeaderResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{4} }

func (m *GetMSLeaderResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetMSLeaderResponse) GetLeader() *MSLeader {
	if m != nil {
		return m.Leader
	}
	return nil
}

type PeerStats struct {
	Peer        *metapb.Peer `protobuf:"bytes,1,opt,name=peer" json:"peer,omitempty"`
	DownSeconds uint64       `protobuf:"varint,2,opt,name=down_seconds,json=downSeconds,proto3" json:"down_seconds,omitempty"`
}

func (m *PeerStats) Reset()                    { *m = PeerStats{} }
func (m *PeerStats) String() string            { return proto.CompactTextString(m) }
func (*PeerStats) ProtoMessage()               {}
func (*PeerStats) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{5} }

func (m *PeerStats) GetPeer() *metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *PeerStats) GetDownSeconds() uint64 {
	if m != nil {
		return m.DownSeconds
	}
	return 0
}

type RangeHeartbeatRequest struct {
	Header *RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Range  *metapb.Range  `protobuf:"bytes,2,opt,name=range" json:"range,omitempty"`
	// Leader Peer sending the heartbeat.
	Leader *metapb.Leader `protobuf:"bytes,3,opt,name=leader" json:"leader,omitempty"`
	// Leader considers that these peers are down.
	DownPeers []*PeerStats `protobuf:"bytes,4,rep,name=down_peers,json=downPeers" json:"down_peers,omitempty"`
	// Pending peers are the peers that the leader can't consider as
	// working followers.
	PendingPeers []*metapb.Peer `protobuf:"bytes,5,rep,name=pending_peers,json=pendingPeers" json:"pending_peers,omitempty"`
	LastTaskId   uint64         `protobuf:"varint,6,opt,name=last_task_id,json=lastTaskId,proto3" json:"last_task_id,omitempty"`
	Score        uint32         `protobuf:"varint,7,opt,name=score,proto3" json:"score,omitempty"`
	// 统计信息暂时放在这里,后面remove
	Stats  *statspb.RangeStats `protobuf:"bytes,8,opt,name=stats" json:"stats,omitempty"`
	Status *statspb.RaftStatus `protobuf:"bytes,9,opt,name=status" json:"status,omitempty"`
}

func (m *RangeHeartbeatRequest) Reset()                    { *m = RangeHeartbeatRequest{} }
func (m *RangeHeartbeatRequest) String() string            { return proto.CompactTextString(m) }
func (*RangeHeartbeatRequest) ProtoMessage()               {}
func (*RangeHeartbeatRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{6} }

func (m *RangeHeartbeatRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *RangeHeartbeatRequest) GetRange() *metapb.Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *RangeHeartbeatRequest) GetLeader() *metapb.Leader {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *RangeHeartbeatRequest) GetDownPeers() []*PeerStats {
	if m != nil {
		return m.DownPeers
	}
	return nil
}

func (m *RangeHeartbeatRequest) GetPendingPeers() []*metapb.Peer {
	if m != nil {
		return m.PendingPeers
	}
	return nil
}

func (m *RangeHeartbeatRequest) GetLastTaskId() uint64 {
	if m != nil {
		return m.LastTaskId
	}
	return 0
}

func (m *RangeHeartbeatRequest) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *RangeHeartbeatRequest) GetStats() *statspb.RangeStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *RangeHeartbeatRequest) GetStatus() *statspb.RaftStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type RangeHeartbeatResponse struct {
	Header  *ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	RangeId uint64          `protobuf:"varint,2,opt,name=range_id,json=rangeId,proto3" json:"range_id,omitempty"`
	Task    *taskpb.Task    `protobuf:"bytes,3,opt,name=task" json:"task,omitempty"`
}

func (m *RangeHeartbeatResponse) Reset()                    { *m = RangeHeartbeatResponse{} }
func (m *RangeHeartbeatResponse) String() string            { return proto.CompactTextString(m) }
func (*RangeHeartbeatResponse) ProtoMessage()               {}
func (*RangeHeartbeatResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{7} }

func (m *RangeHeartbeatResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *RangeHeartbeatResponse) GetRangeId() uint64 {
	if m != nil {
		return m.RangeId
	}
	return 0
}

func (m *RangeHeartbeatResponse) GetTask() *taskpb.Task {
	if m != nil {
		return m.Task
	}
	return nil
}

type NodeHeartbeatRequest struct {
	Header     *RequestHeader   `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	NodeId     uint64           `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	NodeState  metapb.NodeState `protobuf:"varint,3,opt,name=node_state,json=nodeState,proto3,enum=metapb.NodeState" json:"node_state,omitempty"`
	LastTaskId uint64           `protobuf:"varint,4,opt,name=last_task_id,json=lastTaskId,proto3" json:"last_task_id,omitempty"`
	// 所有非处于工作状态的分片ID
	RangesOffline []uint64 `protobuf:"varint,5,rep,packed,name=ranges_offline,json=rangesOffline" json:"ranges_offline,omitempty"`
	Ranges        []uint64 `protobuf:"varint,6,rep,packed,name=ranges" json:"ranges,omitempty"`
	// Total range count in this store.
	RangeCount uint32 `protobuf:"varint,7,opt,name=range_count,json=rangeCount,proto3" json:"range_count,omitempty"`
	// Current range split count.
	RangeSplitCount uint32 `protobuf:"varint,8,opt,name=range_split_count,json=rangeSplitCount,proto3" json:"range_split_count,omitempty"`
	// Current sending snapshot count.
	SendingSnapCount uint32 `protobuf:"varint,9,opt,name=sending_snap_count,json=sendingSnapCount,proto3" json:"sending_snap_count,omitempty"`
	// Current receiving snapshot count.
	ApplyingSnapCount uint32 `protobuf:"varint,10,opt,name=applying_snap_count,json=applyingSnapCount,proto3" json:"applying_snap_count,omitempty"`
	RangeLeaderCount  uint32 `protobuf:"varint,11,opt,name=range_leader_count,json=rangeLeaderCount,proto3" json:"range_leader_count,omitempty"`
	Score             uint32 `protobuf:"varint,12,opt,name=score,proto3" json:"score,omitempty"`
	// 统计信息暂时放在这里
	Stats        *statspb.NodeStats    `protobuf:"bytes,13,opt,name=stats" json:"stats,omitempty"`
	ProcessStats *statspb.ProcessStats `protobuf:"bytes,14,opt,name=process_stats,json=processStats" json:"process_stats,omitempty"`
}

func (m *NodeHeartbeatRequest) Reset()                    { *m = NodeHeartbeatRequest{} }
func (m *NodeHeartbeatRequest) String() string            { return proto.CompactTextString(m) }
func (*NodeHeartbeatRequest) ProtoMessage()               {}
func (*NodeHeartbeatRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{8} }

func (m *NodeHeartbeatRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *NodeHeartbeatRequest) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *NodeHeartbeatRequest) GetNodeState() metapb.NodeState {
	if m != nil {
		return m.NodeState
	}
	return metapb.NodeState_N_Invalid
}

func (m *NodeHeartbeatRequest) GetLastTaskId() uint64 {
	if m != nil {
		return m.LastTaskId
	}
	return 0
}

func (m *NodeHeartbeatRequest) GetRangesOffline() []uint64 {
	if m != nil {
		return m.RangesOffline
	}
	return nil
}

func (m *NodeHeartbeatRequest) GetRanges() []uint64 {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *NodeHeartbeatRequest) GetRangeCount() uint32 {
	if m != nil {
		return m.RangeCount
	}
	return 0
}

func (m *NodeHeartbeatRequest) GetRangeSplitCount() uint32 {
	if m != nil {
		return m.RangeSplitCount
	}
	return 0
}

func (m *NodeHeartbeatRequest) GetSendingSnapCount() uint32 {
	if m != nil {
		return m.SendingSnapCount
	}
	return 0
}

func (m *NodeHeartbeatRequest) GetApplyingSnapCount() uint32 {
	if m != nil {
		return m.ApplyingSnapCount
	}
	return 0
}

func (m *NodeHeartbeatRequest) GetRangeLeaderCount() uint32 {
	if m != nil {
		return m.RangeLeaderCount
	}
	return 0
}

func (m *NodeHeartbeatRequest) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *NodeHeartbeatRequest) GetStats() *statspb.NodeStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *NodeHeartbeatRequest) GetProcessStats() *statspb.ProcessStats {
	if m != nil {
		return m.ProcessStats
	}
	return nil
}

type NodeHeartbeatResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	NodeId uint64          `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Task   *taskpb.Task    `protobuf:"bytes,3,opt,name=task" json:"task,omitempty"`
}

func (m *NodeHeartbeatResponse) Reset()                    { *m = NodeHeartbeatResponse{} }
func (m *NodeHeartbeatResponse) String() string            { return proto.CompactTextString(m) }
func (*NodeHeartbeatResponse) ProtoMessage()               {}
func (*NodeHeartbeatResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{9} }

func (m *NodeHeartbeatResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *NodeHeartbeatResponse) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *NodeHeartbeatResponse) GetTask() *taskpb.Task {
	if m != nil {
		return m.Task
	}
	return nil
}

type GatewayHeartbeatRequest struct {
	Header *RequestHeader    `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Addr   string            `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	Stats  *statspb.SqlStats `protobuf:"bytes,3,opt,name=stats" json:"stats,omitempty"`
	Time   int64             `protobuf:"varint,4,opt,name=time,proto3" json:"time,omitempty"`
}

func (m *GatewayHeartbeatRequest) Reset()                    { *m = GatewayHeartbeatRequest{} }
func (m *GatewayHeartbeatRequest) String() string            { return proto.CompactTextString(m) }
func (*GatewayHeartbeatRequest) ProtoMessage()               {}
func (*GatewayHeartbeatRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{10} }

func (m *GatewayHeartbeatRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GatewayHeartbeatRequest) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

func (m *GatewayHeartbeatRequest) GetStats() *statspb.SqlStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *GatewayHeartbeatRequest) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type GatewayHeartbeatResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
}

func (m *GatewayHeartbeatResponse) Reset()                    { *m = GatewayHeartbeatResponse{} }
func (m *GatewayHeartbeatResponse) String() string            { return proto.CompactTextString(m) }
func (*GatewayHeartbeatResponse) ProtoMessage()               {}
func (*GatewayHeartbeatResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{11} }

func (m *GatewayHeartbeatResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type ReportEventRequest struct {
	Header *RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Event  *eventpb.Event `protobuf:"bytes,2,opt,name=event" json:"event,omitempty"`
}

func (m *ReportEventRequest) Reset()                    { *m = ReportEventRequest{} }
func (m *ReportEventRequest) String() string            { return proto.CompactTextString(m) }
func (*ReportEventRequest) ProtoMessage()               {}
func (*ReportEventRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{12} }

func (m *ReportEventRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ReportEventRequest) GetEvent() *eventpb.Event {
	if m != nil {
		return m.Event
	}
	return nil
}

type ReportEventResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
}

func (m *ReportEventResponse) Reset()                    { *m = ReportEventResponse{} }
func (m *ReportEventResponse) String() string            { return proto.CompactTextString(m) }
func (*ReportEventResponse) ProtoMessage()               {}
func (*ReportEventResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{13} }

func (m *ReportEventResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type GetNodeRequest struct {
	Header *RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Id     uint64         `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetNodeRequest) Reset()                    { *m = GetNodeRequest{} }
func (m *GetNodeRequest) String() string            { return proto.CompactTextString(m) }
func (*GetNodeRequest) ProtoMessage()               {}
func (*GetNodeRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{14} }

func (m *GetNodeRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetNodeRequest) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type GetNodeResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Node   *metapb.Node    `protobuf:"bytes,2,opt,name=node" json:"node,omitempty"`
}

func (m *GetNodeResponse) Reset()                    { *m = GetNodeResponse{} }
func (m *GetNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*GetNodeResponse) ProtoMessage()               {}
func (*GetNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{15} }

func (m *GetNodeResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetNodeResponse) GetNode() *metapb.Node {
	if m != nil {
		return m.Node
	}
	return nil
}

type GetDBRequest struct {
	Header *RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Name   string         `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *GetDBRequest) Reset()                    { *m = GetDBRequest{} }
func (m *GetDBRequest) String() string            { return proto.CompactTextString(m) }
func (*GetDBRequest) ProtoMessage()               {}
func (*GetDBRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{16} }

func (m *GetDBRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetDBRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type GetDBResponse struct {
	Header *ResponseHeader  `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Db     *metapb.DataBase `protobuf:"bytes,2,opt,name=db" json:"db,omitempty"`
}

func (m *GetDBResponse) Reset()                    { *m = GetDBResponse{} }
func (m *GetDBResponse) String() string            { return proto.CompactTextString(m) }
func (*GetDBResponse) ProtoMessage()               {}
func (*GetDBResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{17} }

func (m *GetDBResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetDBResponse) GetDb() *metapb.DataBase {
	if m != nil {
		return m.Db
	}
	return nil
}

type GetTableRequest struct {
	Header    *RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	DbId      uint64         `protobuf:"varint,2,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableName string         `protobuf:"bytes,3,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
}

func (m *GetTableRequest) Reset()                    { *m = GetTableRequest{} }
func (m *GetTableRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTableRequest) ProtoMessage()               {}
func (*GetTableRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{18} }

func (m *GetTableRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetTableRequest) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *GetTableRequest) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

type GetTableByIdRequest struct {
	Header  *RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	DbId    uint64         `protobuf:"varint,2,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId uint64         `protobuf:"varint,3,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
}

func (m *GetTableByIdRequest) Reset()                    { *m = GetTableByIdRequest{} }
func (m *GetTableByIdRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTableByIdRequest) ProtoMessage()               {}
func (*GetTableByIdRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{19} }

func (m *GetTableByIdRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetTableByIdRequest) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *GetTableByIdRequest) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

type GetTableResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Table  *metapb.Table   `protobuf:"bytes,2,opt,name=table" json:"table,omitempty"`
}

func (m *GetTableResponse) Reset()                    { *m = GetTableResponse{} }
func (m *GetTableResponse) String() string            { return proto.CompactTextString(m) }
func (*GetTableResponse) ProtoMessage()               {}
func (*GetTableResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{20} }

func (m *GetTableResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetTableResponse) GetTable() *metapb.Table {
	if m != nil {
		return m.Table
	}
	return nil
}

type GetTableByIdResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Table  *metapb.Table   `protobuf:"bytes,2,opt,name=table" json:"table,omitempty"`
}

func (m *GetTableByIdResponse) Reset()                    { *m = GetTableByIdResponse{} }
func (m *GetTableByIdResponse) String() string            { return proto.CompactTextString(m) }
func (*GetTableByIdResponse) ProtoMessage()               {}
func (*GetTableByIdResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{21} }

func (m *GetTableByIdResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetTableByIdResponse) GetTable() *metapb.Table {
	if m != nil {
		return m.Table
	}
	return nil
}

type GetColumnsRequest struct {
	Header  *RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	DbId    uint64         `protobuf:"varint,2,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId uint64         `protobuf:"varint,3,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
}

func (m *GetColumnsRequest) Reset()                    { *m = GetColumnsRequest{} }
func (m *GetColumnsRequest) String() string            { return proto.CompactTextString(m) }
func (*GetColumnsRequest) ProtoMessage()               {}
func (*GetColumnsRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{22} }

func (m *GetColumnsRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetColumnsRequest) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *GetColumnsRequest) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

type GetColumnsResponse struct {
	Header  *ResponseHeader  `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Columns []*metapb.Column `protobuf:"bytes,2,rep,name=columns" json:"columns,omitempty"`
}

func (m *GetColumnsResponse) Reset()                    { *m = GetColumnsResponse{} }
func (m *GetColumnsResponse) String() string            { return proto.CompactTextString(m) }
func (*GetColumnsResponse) ProtoMessage()               {}
func (*GetColumnsResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{23} }

func (m *GetColumnsResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetColumnsResponse) GetColumns() []*metapb.Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

type GetColumnByNameRequest struct {
	Header  *RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	DbId    uint64         `protobuf:"varint,2,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId uint64         `protobuf:"varint,3,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	ColName string         `protobuf:"bytes,4,opt,name=col_name,json=colName,proto3" json:"col_name,omitempty"`
}

func (m *GetColumnByNameRequest) Reset()                    { *m = GetColumnByNameRequest{} }
func (m *GetColumnByNameRequest) String() string            { return proto.CompactTextString(m) }
func (*GetColumnByNameRequest) ProtoMessage()               {}
func (*GetColumnByNameRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{24} }

func (m *GetColumnByNameRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetColumnByNameRequest) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *GetColumnByNameRequest) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *GetColumnByNameRequest) GetColName() string {
	if m != nil {
		return m.ColName
	}
	return ""
}

type GetColumnByNameResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Column *metapb.Column  `protobuf:"bytes,2,opt,name=column" json:"column,omitempty"`
}

func (m *GetColumnByNameResponse) Reset()                    { *m = GetColumnByNameResponse{} }
func (m *GetColumnByNameResponse) String() string            { return proto.CompactTextString(m) }
func (*GetColumnByNameResponse) ProtoMessage()               {}
func (*GetColumnByNameResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{25} }

func (m *GetColumnByNameResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetColumnByNameResponse) GetColumn() *metapb.Column {
	if m != nil {
		return m.Column
	}
	return nil
}

type GetColumnByIdRequest struct {
	Header  *RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	DbId    uint64         `protobuf:"varint,2,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId uint64         `protobuf:"varint,3,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	ColId   uint64         `protobuf:"varint,4,opt,name=col_id,json=colId,proto3" json:"col_id,omitempty"`
}

func (m *GetColumnByIdRequest) Reset()                    { *m = GetColumnByIdRequest{} }
func (m *GetColumnByIdRequest) String() string            { return proto.CompactTextString(m) }
func (*GetColumnByIdRequest) ProtoMessage()               {}
func (*GetColumnByIdRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{26} }

func (m *GetColumnByIdRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetColumnByIdRequest) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *GetColumnByIdRequest) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *GetColumnByIdRequest) GetColId() uint64 {
	if m != nil {
		return m.ColId
	}
	return 0
}

type GetColumnByIdResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Column *metapb.Column  `protobuf:"bytes,2,opt,name=column" json:"column,omitempty"`
}

func (m *GetColumnByIdResponse) Reset()                    { *m = GetColumnByIdResponse{} }
func (m *GetColumnByIdResponse) String() string            { return proto.CompactTextString(m) }
func (*GetColumnByIdResponse) ProtoMessage()               {}
func (*GetColumnByIdResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{27} }

func (m *GetColumnByIdResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *GetColumnByIdResponse) GetColumn() *metapb.Column {
	if m != nil {
		return m.Column
	}
	return nil
}

type AddColumnRequest struct {
	Header  *RequestHeader   `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	DbId    uint64           `protobuf:"varint,2,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId uint64           `protobuf:"varint,3,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
	Columns []*metapb.Column `protobuf:"bytes,4,rep,name=columns" json:"columns,omitempty"`
}

func (m *AddColumnRequest) Reset()                    { *m = AddColumnRequest{} }
func (m *AddColumnRequest) String() string            { return proto.CompactTextString(m) }
func (*AddColumnRequest) ProtoMessage()               {}
func (*AddColumnRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{28} }

func (m *AddColumnRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *AddColumnRequest) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *AddColumnRequest) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

func (m *AddColumnRequest) GetColumns() []*metapb.Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

type AddColumnResponse struct {
	Header  *ResponseHeader  `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Columns []*metapb.Column `protobuf:"bytes,2,rep,name=columns" json:"columns,omitempty"`
}

func (m *AddColumnResponse) Reset()                    { *m = AddColumnResponse{} }
func (m *AddColumnResponse) String() string            { return proto.CompactTextString(m) }
func (*AddColumnResponse) ProtoMessage()               {}
func (*AddColumnResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{29} }

func (m *AddColumnResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *AddColumnResponse) GetColumns() []*metapb.Column {
	if m != nil {
		return m.Columns
	}
	return nil
}

type TruncateTableRequest struct {
	Header  *RequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	DbId    uint64         `protobuf:"varint,2,opt,name=db_id,json=dbId,proto3" json:"db_id,omitempty"`
	TableId uint64         `protobuf:"varint,3,opt,name=table_id,json=tableId,proto3" json:"table_id,omitempty"`
}

func (m *TruncateTableRequest) Reset()                    { *m = TruncateTableRequest{} }
func (m *TruncateTableRequest) String() string            { return proto.CompactTextString(m) }
func (*TruncateTableRequest) ProtoMessage()               {}
func (*TruncateTableRequest) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{30} }

func (m *TruncateTableRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *TruncateTableRequest) GetDbId() uint64 {
	if m != nil {
		return m.DbId
	}
	return 0
}

func (m *TruncateTableRequest) GetTableId() uint64 {
	if m != nil {
		return m.TableId
	}
	return 0
}

type TruncateTableResponse struct {
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
}

func (m *TruncateTableResponse) Reset()                    { *m = TruncateTableResponse{} }
func (m *TruncateTableResponse) String() string            { return proto.CompactTextString(m) }
func (*TruncateTableResponse) ProtoMessage()               {}
func (*TruncateTableResponse) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{31} }

func (m *TruncateTableResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type RequestHeader struct {
	ClusterId uint64 `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
}

func (m *RequestHeader) Reset()                    { *m = RequestHeader{} }
func (m *RequestHeader) String() string            { return proto.CompactTextString(m) }
func (*RequestHeader) ProtoMessage()               {}
func (*RequestHeader) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{32} }

func (m *RequestHeader) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

type ResponseHeader struct {
	ClusterId uint64 `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	Error     *Error `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *ResponseHeader) Reset()                    { *m = ResponseHeader{} }
func (m *ResponseHeader) String() string            { return proto.CompactTextString(m) }
func (*ResponseHeader) ProtoMessage()               {}
func (*ResponseHeader) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{33} }

func (m *ResponseHeader) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *ResponseHeader) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type MsLeader struct {
	MsLeader string `protobuf:"bytes,1,opt,name=ms_leader,json=msLeader,proto3" json:"ms_leader,omitempty"`
}

func (m *MsLeader) Reset()                    { *m = MsLeader{} }
func (m *MsLeader) String() string            { return proto.CompactTextString(m) }
func (*MsLeader) ProtoMessage()               {}
func (*MsLeader) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{34} }

func (m *MsLeader) GetMsLeader() string {
	if m != nil {
		return m.MsLeader
	}
	return ""
}

type NoLeader struct {
}

func (m *NoLeader) Reset()                    { *m = NoLeader{} }
func (m *NoLeader) String() string            { return proto.CompactTextString(m) }
func (*NoLeader) ProtoMessage()               {}
func (*NoLeader) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{35} }

type Error struct {
	MsLeader *MsLeader `protobuf:"bytes,2,opt,name=ms_leader,json=msLeader" json:"ms_leader,omitempty"`
	NoLeader *NoLeader `protobuf:"bytes,3,opt,name=no_leader,json=noLeader" json:"no_leader,omitempty"`
}

func (m *Error) Reset()                    { *m = Error{} }
func (m *Error) String() string            { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()               {}
func (*Error) Descriptor() ([]byte, []int) { return fileDescriptorMspb, []int{36} }

func (m *Error) GetMsLeader() *MsLeader {
	if m != nil {
		return m.MsLeader
	}
	return nil
}

func (m *Error) GetNoLeader() *NoLeader {
	if m != nil {
		return m.NoLeader
	}
	return nil
}

func init() {
	proto.RegisterType((*GetTopologyEpochRequest)(nil), "mspb.GetTopologyEpochRequest")
	proto.RegisterType((*GetTopologyEpochResponse)(nil), "mspb.GetTopologyEpochResponse")
	proto.RegisterType((*MSLeader)(nil), "mspb.MSLeader")
	proto.RegisterType((*GetMSLeaderRequest)(nil), "mspb.GetMSLeaderRequest")
	proto.RegisterType((*GetMSLeaderResponse)(nil), "mspb.GetMSLeaderResponse")
	proto.RegisterType((*PeerStats)(nil), "mspb.PeerStats")
	proto.RegisterType((*RangeHeartbeatRequest)(nil), "mspb.RangeHeartbeatRequest")
	proto.RegisterType((*RangeHeartbeatResponse)(nil), "mspb.RangeHeartbeatResponse")
	proto.RegisterType((*NodeHeartbeatRequest)(nil), "mspb.NodeHeartbeatRequest")
	proto.RegisterType((*NodeHeartbeatResponse)(nil), "mspb.NodeHeartbeatResponse")
	proto.RegisterType((*GatewayHeartbeatRequest)(nil), "mspb.GatewayHeartbeatRequest")
	proto.RegisterType((*GatewayHeartbeatResponse)(nil), "mspb.GatewayHeartbeatResponse")
	proto.RegisterType((*ReportEventRequest)(nil), "mspb.ReportEventRequest")
	proto.RegisterType((*ReportEventResponse)(nil), "mspb.ReportEventResponse")
	proto.RegisterType((*GetNodeRequest)(nil), "mspb.GetNodeRequest")
	proto.RegisterType((*GetNodeResponse)(nil), "mspb.GetNodeResponse")
	proto.RegisterType((*GetDBRequest)(nil), "mspb.GetDBRequest")
	proto.RegisterType((*GetDBResponse)(nil), "mspb.GetDBResponse")
	proto.RegisterType((*GetTableRequest)(nil), "mspb.GetTableRequest")
	proto.RegisterType((*GetTableByIdRequest)(nil), "mspb.GetTableByIdRequest")
	proto.RegisterType((*GetTableResponse)(nil), "mspb.GetTableResponse")
	proto.RegisterType((*GetTableByIdResponse)(nil), "mspb.GetTableByIdResponse")
	proto.RegisterType((*GetColumnsRequest)(nil), "mspb.GetColumnsRequest")
	proto.RegisterType((*GetColumnsResponse)(nil), "mspb.GetColumnsResponse")
	proto.RegisterType((*GetColumnByNameRequest)(nil), "mspb.GetColumnByNameRequest")
	proto.RegisterType((*GetColumnByNameResponse)(nil), "mspb.GetColumnByNameResponse")
	proto.RegisterType((*GetColumnByIdRequest)(nil), "mspb.GetColumnByIdRequest")
	proto.RegisterType((*GetColumnByIdResponse)(nil), "mspb.GetColumnByIdResponse")
	proto.RegisterType((*AddColumnRequest)(nil), "mspb.AddColumnRequest")
	proto.RegisterType((*AddColumnResponse)(nil), "mspb.AddColumnResponse")
	proto.RegisterType((*TruncateTableRequest)(nil), "mspb.TruncateTableRequest")
	proto.RegisterType((*TruncateTableResponse)(nil), "mspb.TruncateTableResponse")
	proto.RegisterType((*RequestHeader)(nil), "mspb.RequestHeader")
	proto.RegisterType((*ResponseHeader)(nil), "mspb.ResponseHeader")
	proto.RegisterType((*MsLeader)(nil), "mspb.MsLeader")
	proto.RegisterType((*NoLeader)(nil), "mspb.NoLeader")
	proto.RegisterType((*Error)(nil), "mspb.Error")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MsServer service

type MsServerClient interface {
	GatewayHeartbeat(ctx context.Context, in *GatewayHeartbeatRequest, opts ...grpc.CallOption) (*GatewayHeartbeatResponse, error)
	NodeHeartbeat(ctx context.Context, in *NodeHeartbeatRequest, opts ...grpc.CallOption) (*NodeHeartbeatResponse, error)
	RangeHeartbeat(ctx context.Context, in *RangeHeartbeatRequest, opts ...grpc.CallOption) (*RangeHeartbeatResponse, error)
	// ReportEvent report event to master server
	ReportEvent(ctx context.Context, in *ReportEventRequest, opts ...grpc.CallOption) (*ReportEventResponse, error)
	GetTopologyEpoch(ctx context.Context, in *GetTopologyEpochRequest, opts ...grpc.CallOption) (*GetTopologyEpochResponse, error)
	GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*GetNodeResponse, error)
	GetDB(ctx context.Context, in *GetDBRequest, opts ...grpc.CallOption) (*GetDBResponse, error)
	GetTable(ctx context.Context, in *GetTableRequest, opts ...grpc.CallOption) (*GetTableResponse, error)
	GetTableById(ctx context.Context, in *GetTableByIdRequest, opts ...grpc.CallOption) (*GetTableByIdResponse, error)
	GetColumns(ctx context.Context, in *GetColumnsRequest, opts ...grpc.CallOption) (*GetColumnsResponse, error)
	GetColumnByName(ctx context.Context, in *GetColumnByNameRequest, opts ...grpc.CallOption) (*GetColumnByNameResponse, error)
	GetColumnById(ctx context.Context, in *GetColumnByIdRequest, opts ...grpc.CallOption) (*GetColumnByIdResponse, error)
	GetMSLeader(ctx context.Context, in *GetMSLeaderRequest, opts ...grpc.CallOption) (*GetMSLeaderResponse, error)
	TruncateTable(ctx context.Context, in *TruncateTableRequest, opts ...grpc.CallOption) (*TruncateTableResponse, error)
	AddColumn(ctx context.Context, in *AddColumnRequest, opts ...grpc.CallOption) (*AddColumnResponse, error)
}

type msServerClient struct {
	cc *grpc.ClientConn
}

func NewMsServerClient(cc *grpc.ClientConn) MsServerClient {
	return &msServerClient{cc}
}

func (c *msServerClient) GatewayHeartbeat(ctx context.Context, in *GatewayHeartbeatRequest, opts ...grpc.CallOption) (*GatewayHeartbeatResponse, error) {
	out := new(GatewayHeartbeatResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/GatewayHeartbeat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msServerClient) NodeHeartbeat(ctx context.Context, in *NodeHeartbeatRequest, opts ...grpc.CallOption) (*NodeHeartbeatResponse, error) {
	out := new(NodeHeartbeatResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/NodeHeartbeat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msServerClient) RangeHeartbeat(ctx context.Context, in *RangeHeartbeatRequest, opts ...grpc.CallOption) (*RangeHeartbeatResponse, error) {
	out := new(RangeHeartbeatResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/RangeHeartbeat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msServerClient) ReportEvent(ctx context.Context, in *ReportEventRequest, opts ...grpc.CallOption) (*ReportEventResponse, error) {
	out := new(ReportEventResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/ReportEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msServerClient) GetTopologyEpoch(ctx context.Context, in *GetTopologyEpochRequest, opts ...grpc.CallOption) (*GetTopologyEpochResponse, error) {
	out := new(GetTopologyEpochResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/GetTopologyEpoch", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msServerClient) GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*GetNodeResponse, error) {
	out := new(GetNodeResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/GetNode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msServerClient) GetDB(ctx context.Context, in *GetDBRequest, opts ...grpc.CallOption) (*GetDBResponse, error) {
	out := new(GetDBResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/GetDB", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msServerClient) GetTable(ctx context.Context, in *GetTableRequest, opts ...grpc.CallOption) (*GetTableResponse, error) {
	out := new(GetTableResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/GetTable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msServerClient) GetTableById(ctx context.Context, in *GetTableByIdRequest, opts ...grpc.CallOption) (*GetTableByIdResponse, error) {
	out := new(GetTableByIdResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/GetTableById", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msServerClient) GetColumns(ctx context.Context, in *GetColumnsRequest, opts ...grpc.CallOption) (*GetColumnsResponse, error) {
	out := new(GetColumnsResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/GetColumns", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msServerClient) GetColumnByName(ctx context.Context, in *GetColumnByNameRequest, opts ...grpc.CallOption) (*GetColumnByNameResponse, error) {
	out := new(GetColumnByNameResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/GetColumnByName", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msServerClient) GetColumnById(ctx context.Context, in *GetColumnByIdRequest, opts ...grpc.CallOption) (*GetColumnByIdResponse, error) {
	out := new(GetColumnByIdResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/GetColumnById", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msServerClient) GetMSLeader(ctx context.Context, in *GetMSLeaderRequest, opts ...grpc.CallOption) (*GetMSLeaderResponse, error) {
	out := new(GetMSLeaderResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/GetMSLeader", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msServerClient) TruncateTable(ctx context.Context, in *TruncateTableRequest, opts ...grpc.CallOption) (*TruncateTableResponse, error) {
	out := new(TruncateTableResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/TruncateTable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msServerClient) AddColumn(ctx context.Context, in *AddColumnRequest, opts ...grpc.CallOption) (*AddColumnResponse, error) {
	out := new(AddColumnResponse)
	err := grpc.Invoke(ctx, "/mspb.MsServer/AddColumn", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MsServer service

type MsServerServer interface {
	GatewayHeartbeat(context.Context, *GatewayHeartbeatRequest) (*GatewayHeartbeatResponse, error)
	NodeHeartbeat(context.Context, *NodeHeartbeatRequest) (*NodeHeartbeatResponse, error)
	RangeHeartbeat(context.Context, *RangeHeartbeatRequest) (*RangeHeartbeatResponse, error)
	// ReportEvent report event to master server
	ReportEvent(context.Context, *ReportEventRequest) (*ReportEventResponse, error)
	GetTopologyEpoch(context.Context, *GetTopologyEpochRequest) (*GetTopologyEpochResponse, error)
	GetNode(context.Context, *GetNodeRequest) (*GetNodeResponse, error)
	GetDB(context.Context, *GetDBRequest) (*GetDBResponse, error)
	GetTable(context.Context, *GetTableRequest) (*GetTableResponse, error)
	GetTableById(context.Context, *GetTableByIdRequest) (*GetTableByIdResponse, error)
	GetColumns(context.Context, *GetColumnsRequest) (*GetColumnsResponse, error)
	GetColumnByName(context.Context, *GetColumnByNameRequest) (*GetColumnByNameResponse, error)
	GetColumnById(context.Context, *GetColumnByIdRequest) (*GetColumnByIdResponse, error)
	GetMSLeader(context.Context, *GetMSLeaderRequest) (*GetMSLeaderResponse, error)
	TruncateTable(context.Context, *TruncateTableRequest) (*TruncateTableResponse, error)
	AddColumn(context.Context, *AddColumnRequest) (*AddColumnResponse, error)
}

func RegisterMsServerServer(s *grpc.Server, srv MsServerServer) {
	s.RegisterService(&_MsServer_serviceDesc, srv)
}

func _MsServer_GatewayHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GatewayHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).GatewayHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/GatewayHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).GatewayHeartbeat(ctx, req.(*GatewayHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MsServer_NodeHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).NodeHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/NodeHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).NodeHeartbeat(ctx, req.(*NodeHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MsServer_RangeHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RangeHeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).RangeHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/RangeHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).RangeHeartbeat(ctx, req.(*RangeHeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MsServer_ReportEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).ReportEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/ReportEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).ReportEvent(ctx, req.(*ReportEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MsServer_GetTopologyEpoch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopologyEpochRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).GetTopologyEpoch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/GetTopologyEpoch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).GetTopologyEpoch(ctx, req.(*GetTopologyEpochRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MsServer_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).GetNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/GetNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).GetNode(ctx, req.(*GetNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MsServer_GetDB_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDBRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).GetDB(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/GetDB",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).GetDB(ctx, req.(*GetDBRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MsServer_GetTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).GetTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/GetTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).GetTable(ctx, req.(*GetTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MsServer_GetTableById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTableByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).GetTableById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/GetTableById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).GetTableById(ctx, req.(*GetTableByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MsServer_GetColumns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetColumnsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).GetColumns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/GetColumns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).GetColumns(ctx, req.(*GetColumnsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MsServer_GetColumnByName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetColumnByNameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).GetColumnByName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/GetColumnByName",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).GetColumnByName(ctx, req.(*GetColumnByNameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MsServer_GetColumnById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetColumnByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).GetColumnById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/GetColumnById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).GetColumnById(ctx, req.(*GetColumnByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MsServer_GetMSLeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMSLeaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).GetMSLeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/GetMSLeader",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).GetMSLeader(ctx, req.(*GetMSLeaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MsServer_TruncateTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TruncateTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).TruncateTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/TruncateTable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).TruncateTable(ctx, req.(*TruncateTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MsServer_AddColumn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddColumnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsServerServer).AddColumn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mspb.MsServer/AddColumn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsServerServer).AddColumn(ctx, req.(*AddColumnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _MsServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mspb.MsServer",
	HandlerType: (*MsServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GatewayHeartbeat",
			Handler:    _MsServer_GatewayHeartbeat_Handler,
		},
		{
			MethodName: "NodeHeartbeat",
			Handler:    _MsServer_NodeHeartbeat_Handler,
		},
		{
			MethodName: "RangeHeartbeat",
			Handler:    _MsServer_RangeHeartbeat_Handler,
		},
		{
			MethodName: "ReportEvent",
			Handler:    _MsServer_ReportEvent_Handler,
		},
		{
			MethodName: "GetTopologyEpoch",
			Handler:    _MsServer_GetTopologyEpoch_Handler,
		},
		{
			MethodName: "GetNode",
			Handler:    _MsServer_GetNode_Handler,
		},
		{
			MethodName: "GetDB",
			Handler:    _MsServer_GetDB_Handler,
		},
		{
			MethodName: "GetTable",
			Handler:    _MsServer_GetTable_Handler,
		},
		{
			MethodName: "GetTableById",
			Handler:    _MsServer_GetTableById_Handler,
		},
		{
			MethodName: "GetColumns",
			Handler:    _MsServer_GetColumns_Handler,
		},
		{
			MethodName: "GetColumnByName",
			Handler:    _MsServer_GetColumnByName_Handler,
		},
		{
			MethodName: "GetColumnById",
			Handler:    _MsServer_GetColumnById_Handler,
		},
		{
			MethodName: "GetMSLeader",
			Handler:    _MsServer_GetMSLeader_Handler,
		},
		{
			MethodName: "TruncateTable",
			Handler:    _MsServer_TruncateTable_Handler,
		},
		{
			MethodName: "AddColumn",
			Handler:    _MsServer_AddColumn_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mspb.proto",
}

func (m *GetTopologyEpochRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopologyEpochRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n1, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.DbId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.DbId))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.TableId))
	}
	if m.CurEpoch != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.CurEpoch.Size()))
		n2, err := m.CurEpoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *GetTopologyEpochResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopologyEpochResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n3, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMspb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Epoch != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Epoch.Size()))
		n4, err := m.Epoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.RwPolicy != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.RwPolicy.Size()))
		n5, err := m.RwPolicy.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *MSLeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MSLeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Id))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspb(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *GetMSLeaderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMSLeaderRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n6, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *GetMSLeaderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMSLeaderResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n7, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Leader != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Leader.Size()))
		n8, err := m.Leader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *PeerStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Peer.Size()))
		n9, err := m.Peer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.DownSeconds != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.DownSeconds))
	}
	return i, nil
}

func (m *RangeHeartbeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeHeartbeatRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n10, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Range != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Range.Size()))
		n11, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Leader != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Leader.Size()))
		n12, err := m.Leader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if len(m.DownPeers) > 0 {
		for _, msg := range m.DownPeers {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMspb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PendingPeers) > 0 {
		for _, msg := range m.PendingPeers {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintMspb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LastTaskId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.LastTaskId))
	}
	if m.Score != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Score))
	}
	if m.Stats != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Stats.Size()))
		n13, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Status != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Status.Size()))
		n14, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *RangeHeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeHeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n15, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.RangeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.RangeId))
	}
	if m.Task != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Task.Size()))
		n16, err := m.Task.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *NodeHeartbeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeHeartbeatRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n17, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.NodeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.NodeId))
	}
	if m.NodeState != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.NodeState))
	}
	if m.LastTaskId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.LastTaskId))
	}
	if len(m.RangesOffline) > 0 {
		dAtA19 := make([]byte, len(m.RangesOffline)*10)
		var j18 int
		for _, num := range m.RangesOffline {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMspb(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	if len(m.Ranges) > 0 {
		dAtA21 := make([]byte, len(m.Ranges)*10)
		var j20 int
		for _, num := range m.Ranges {
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintMspb(dAtA, i, uint64(j20))
		i += copy(dAtA[i:], dAtA21[:j20])
	}
	if m.RangeCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.RangeCount))
	}
	if m.RangeSplitCount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.RangeSplitCount))
	}
	if m.SendingSnapCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.SendingSnapCount))
	}
	if m.ApplyingSnapCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.ApplyingSnapCount))
	}
	if m.RangeLeaderCount != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.RangeLeaderCount))
	}
	if m.Score != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Score))
	}
	if m.Stats != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Stats.Size()))
		n22, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.ProcessStats != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.ProcessStats.Size()))
		n23, err := m.ProcessStats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *NodeHeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeHeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n24, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.NodeId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.NodeId))
	}
	if m.Task != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Task.Size()))
		n25, err := m.Task.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *GatewayHeartbeatRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayHeartbeatRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n26, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if len(m.Addr) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspb(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.Stats != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Stats.Size()))
		n27, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Time != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Time))
	}
	return i, nil
}

func (m *GatewayHeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GatewayHeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n28, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *ReportEventRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportEventRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n29, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.Event != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Event.Size()))
		n30, err := m.Event.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *ReportEventResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportEventResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n31, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *GetNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n32, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.Id != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *GetNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n33, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.Node != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Node.Size()))
		n34, err := m.Node.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	return i, nil
}

func (m *GetDBRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDBRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n35, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *GetDBResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDBResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n36, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Db != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Db.Size()))
		n37, err := m.Db.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *GetTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTableRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n38, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.DbId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.DbId))
	}
	if len(m.TableName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMspb(dAtA, i, uint64(len(m.TableName)))
		i += copy(dAtA[i:], m.TableName)
	}
	return i, nil
}

func (m *GetTableByIdRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTableByIdRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n39, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.DbId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.DbId))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.TableId))
	}
	return i, nil
}

func (m *GetTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTableResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n40, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.Table != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Table.Size()))
		n41, err := m.Table.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}

func (m *GetTableByIdResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTableByIdResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n42, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Table != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Table.Size()))
		n43, err := m.Table.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}

func (m *GetColumnsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetColumnsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n44, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.DbId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.DbId))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.TableId))
	}
	return i, nil
}

func (m *GetColumnsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetColumnsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n45, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMspb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetColumnByNameRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetColumnByNameRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n46, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.DbId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.DbId))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.TableId))
	}
	if len(m.ColName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMspb(dAtA, i, uint64(len(m.ColName)))
		i += copy(dAtA[i:], m.ColName)
	}
	return i, nil
}

func (m *GetColumnByNameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetColumnByNameResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n47, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.Column != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Column.Size()))
		n48, err := m.Column.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	return i, nil
}

func (m *GetColumnByIdRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetColumnByIdRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n49, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.DbId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.DbId))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.TableId))
	}
	if m.ColId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.ColId))
	}
	return i, nil
}

func (m *GetColumnByIdResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetColumnByIdResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n50, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.Column != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Column.Size()))
		n51, err := m.Column.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	return i, nil
}

func (m *AddColumnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddColumnRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n52, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if m.DbId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.DbId))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.TableId))
	}
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMspb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AddColumnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddColumnResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n53, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if len(m.Columns) > 0 {
		for _, msg := range m.Columns {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMspb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *TruncateTableRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TruncateTableRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n54, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.DbId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.DbId))
	}
	if m.TableId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.TableId))
	}
	return i, nil
}

func (m *TruncateTableResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TruncateTableResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Header.Size()))
		n55, err := m.Header.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	return i, nil
}

func (m *RequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClusterId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.ClusterId))
	}
	return i, nil
}

func (m *ResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClusterId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.ClusterId))
	}
	if m.Error != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.Error.Size()))
		n56, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	return i, nil
}

func (m *MsLeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsLeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MsLeader) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMspb(dAtA, i, uint64(len(m.MsLeader)))
		i += copy(dAtA[i:], m.MsLeader)
	}
	return i, nil
}

func (m *NoLeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NoLeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MsLeader != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.MsLeader.Size()))
		n57, err := m.MsLeader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.NoLeader != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMspb(dAtA, i, uint64(m.NoLeader.Size()))
		n58, err := m.NoLeader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	return i, nil
}

func encodeFixed64Mspb(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Mspb(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMspb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GetTopologyEpochRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.DbId != 0 {
		n += 1 + sovMspb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovMspb(uint64(m.TableId))
	}
	if m.CurEpoch != nil {
		l = m.CurEpoch.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *GetTopologyEpochResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovMspb(uint64(l))
		}
	}
	if m.Epoch != nil {
		l = m.Epoch.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.RwPolicy != nil {
		l = m.RwPolicy.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *MSLeader) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMspb(uint64(m.Id))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *GetMSLeaderRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *GetMSLeaderResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *PeerStats) Size() (n int) {
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.DownSeconds != 0 {
		n += 1 + sovMspb(uint64(m.DownSeconds))
	}
	return n
}

func (m *RangeHeartbeatRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if len(m.DownPeers) > 0 {
		for _, e := range m.DownPeers {
			l = e.Size()
			n += 1 + l + sovMspb(uint64(l))
		}
	}
	if len(m.PendingPeers) > 0 {
		for _, e := range m.PendingPeers {
			l = e.Size()
			n += 1 + l + sovMspb(uint64(l))
		}
	}
	if m.LastTaskId != 0 {
		n += 1 + sovMspb(uint64(m.LastTaskId))
	}
	if m.Score != 0 {
		n += 1 + sovMspb(uint64(m.Score))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *RangeHeartbeatResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.RangeId != 0 {
		n += 1 + sovMspb(uint64(m.RangeId))
	}
	if m.Task != nil {
		l = m.Task.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *NodeHeartbeatRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.NodeId != 0 {
		n += 1 + sovMspb(uint64(m.NodeId))
	}
	if m.NodeState != 0 {
		n += 1 + sovMspb(uint64(m.NodeState))
	}
	if m.LastTaskId != 0 {
		n += 1 + sovMspb(uint64(m.LastTaskId))
	}
	if len(m.RangesOffline) > 0 {
		l = 0
		for _, e := range m.RangesOffline {
			l += sovMspb(uint64(e))
		}
		n += 1 + sovMspb(uint64(l)) + l
	}
	if len(m.Ranges) > 0 {
		l = 0
		for _, e := range m.Ranges {
			l += sovMspb(uint64(e))
		}
		n += 1 + sovMspb(uint64(l)) + l
	}
	if m.RangeCount != 0 {
		n += 1 + sovMspb(uint64(m.RangeCount))
	}
	if m.RangeSplitCount != 0 {
		n += 1 + sovMspb(uint64(m.RangeSplitCount))
	}
	if m.SendingSnapCount != 0 {
		n += 1 + sovMspb(uint64(m.SendingSnapCount))
	}
	if m.ApplyingSnapCount != 0 {
		n += 1 + sovMspb(uint64(m.ApplyingSnapCount))
	}
	if m.RangeLeaderCount != 0 {
		n += 1 + sovMspb(uint64(m.RangeLeaderCount))
	}
	if m.Score != 0 {
		n += 1 + sovMspb(uint64(m.Score))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.ProcessStats != nil {
		l = m.ProcessStats.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *NodeHeartbeatResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.NodeId != 0 {
		n += 1 + sovMspb(uint64(m.NodeId))
	}
	if m.Task != nil {
		l = m.Task.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *GatewayHeartbeatRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovMspb(uint64(m.Time))
	}
	return n
}

func (m *GatewayHeartbeatResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *ReportEventRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.Event != nil {
		l = m.Event.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *ReportEventResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *GetNodeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovMspb(uint64(m.Id))
	}
	return n
}

func (m *GetNodeResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *GetDBRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *GetDBResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.Db != nil {
		l = m.Db.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *GetTableRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.DbId != 0 {
		n += 1 + sovMspb(uint64(m.DbId))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *GetTableByIdRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.DbId != 0 {
		n += 1 + sovMspb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovMspb(uint64(m.TableId))
	}
	return n
}

func (m *GetTableResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *GetTableByIdResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.Table != nil {
		l = m.Table.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *GetColumnsRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.DbId != 0 {
		n += 1 + sovMspb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovMspb(uint64(m.TableId))
	}
	return n
}

func (m *GetColumnsResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovMspb(uint64(l))
		}
	}
	return n
}

func (m *GetColumnByNameRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.DbId != 0 {
		n += 1 + sovMspb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovMspb(uint64(m.TableId))
	}
	l = len(m.ColName)
	if l > 0 {
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *GetColumnByNameResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.Column != nil {
		l = m.Column.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *GetColumnByIdRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.DbId != 0 {
		n += 1 + sovMspb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovMspb(uint64(m.TableId))
	}
	if m.ColId != 0 {
		n += 1 + sovMspb(uint64(m.ColId))
	}
	return n
}

func (m *GetColumnByIdResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.Column != nil {
		l = m.Column.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *AddColumnRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.DbId != 0 {
		n += 1 + sovMspb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovMspb(uint64(m.TableId))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovMspb(uint64(l))
		}
	}
	return n
}

func (m *AddColumnResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovMspb(uint64(l))
		}
	}
	return n
}

func (m *TruncateTableRequest) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.DbId != 0 {
		n += 1 + sovMspb(uint64(m.DbId))
	}
	if m.TableId != 0 {
		n += 1 + sovMspb(uint64(m.TableId))
	}
	return n
}

func (m *TruncateTableResponse) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *RequestHeader) Size() (n int) {
	var l int
	_ = l
	if m.ClusterId != 0 {
		n += 1 + sovMspb(uint64(m.ClusterId))
	}
	return n
}

func (m *ResponseHeader) Size() (n int) {
	var l int
	_ = l
	if m.ClusterId != 0 {
		n += 1 + sovMspb(uint64(m.ClusterId))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *MsLeader) Size() (n int) {
	var l int
	_ = l
	l = len(m.MsLeader)
	if l > 0 {
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func (m *NoLeader) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *Error) Size() (n int) {
	var l int
	_ = l
	if m.MsLeader != nil {
		l = m.MsLeader.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	if m.NoLeader != nil {
		l = m.NoLeader.Size()
		n += 1 + l + sovMspb(uint64(l))
	}
	return n
}

func sovMspb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMspb(x uint64) (n int) {
	return sovMspb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GetTopologyEpochRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopologyEpochRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopologyEpochRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurEpoch == nil {
				m.CurEpoch = &metapb.TableEpoch{}
			}
			if err := m.CurEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopologyEpochResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopologyEpochResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopologyEpochResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &metapb.Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Epoch == nil {
				m.Epoch = &metapb.TableEpoch{}
			}
			if err := m.Epoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RwPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RwPolicy == nil {
				m.RwPolicy = &metapb.TableRwPolicy{}
			}
			if err := m.RwPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MSLeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MSLeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MSLeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMSLeaderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMSLeaderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMSLeaderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMSLeaderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMSLeaderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMSLeaderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &MSLeader{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &metapb.Peer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownSeconds", wireType)
			}
			m.DownSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownSeconds |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeHeartbeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeHeartbeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeHeartbeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &metapb.Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &metapb.Leader{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownPeers = append(m.DownPeers, &PeerStats{})
			if err := m.DownPeers[len(m.DownPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingPeers = append(m.PendingPeers, &metapb.Peer{})
			if err := m.PendingPeers[len(m.PendingPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTaskId", wireType)
			}
			m.LastTaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastTaskId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &statspb.RangeStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &statspb.RaftStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeHeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeHeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeHeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeId", wireType)
			}
			m.RangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Task == nil {
				m.Task = &taskpb.Task{}
			}
			if err := m.Task.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeHeartbeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeHeartbeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeHeartbeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeState", wireType)
			}
			m.NodeState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeState |= (metapb.NodeState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTaskId", wireType)
			}
			m.LastTaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastTaskId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMspb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RangesOffline = append(m.RangesOffline, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMspb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMspb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMspb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RangesOffline = append(m.RangesOffline, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RangesOffline", wireType)
			}
		case 6:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMspb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Ranges = append(m.Ranges, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMspb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMspb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMspb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Ranges = append(m.Ranges, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeCount", wireType)
			}
			m.RangeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeSplitCount", wireType)
			}
			m.RangeSplitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeSplitCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendingSnapCount", wireType)
			}
			m.SendingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendingSnapCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyingSnapCount", wireType)
			}
			m.ApplyingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyingSnapCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeLeaderCount", wireType)
			}
			m.RangeLeaderCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeLeaderCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &statspb.NodeStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProcessStats == nil {
				m.ProcessStats = &statspb.ProcessStats{}
			}
			if err := m.ProcessStats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeHeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeHeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeHeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Task == nil {
				m.Task = &taskpb.Task{}
			}
			if err := m.Task.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayHeartbeatRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GatewayHeartbeatRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GatewayHeartbeatRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &statspb.SqlStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GatewayHeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GatewayHeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GatewayHeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportEventRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportEventRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportEventRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Event == nil {
				m.Event = &eventpb.Event{}
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportEventResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportEventResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportEventResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &metapb.Node{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDBRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDBRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDBRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDBResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDBResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDBResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Db", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Db == nil {
				m.Db = &metapb.DataBase{}
			}
			if err := m.Db.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTableByIdRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTableByIdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTableByIdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Table == nil {
				m.Table = &metapb.Table{}
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTableByIdResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTableByIdResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTableByIdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Table == nil {
				m.Table = &metapb.Table{}
			}
			if err := m.Table.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetColumnsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetColumnsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetColumnsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetColumnsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetColumnsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetColumnsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &metapb.Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetColumnByNameRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetColumnByNameRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetColumnByNameRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetColumnByNameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetColumnByNameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetColumnByNameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Column == nil {
				m.Column = &metapb.Column{}
			}
			if err := m.Column.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetColumnByIdRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetColumnByIdRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetColumnByIdRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColId", wireType)
			}
			m.ColId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetColumnByIdResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetColumnByIdResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetColumnByIdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Column == nil {
				m.Column = &metapb.Column{}
			}
			if err := m.Column.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddColumnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddColumnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddColumnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &metapb.Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddColumnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddColumnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddColumnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &metapb.Column{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TruncateTableRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TruncateTableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TruncateTableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbId", wireType)
			}
			m.DbId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DbId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableId", wireType)
			}
			m.TableId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TableId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TruncateTableResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TruncateTableResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TruncateTableResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsLeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsLeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsLeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsLeader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsLeader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NoLeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NoLeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NoLeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MsLeader == nil {
				m.MsLeader = &MsLeader{}
			}
			if err := m.MsLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NoLeader == nil {
				m.NoLeader = &NoLeader{}
			}
			if err := m.NoLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMspb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMspb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMspb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMspb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMspb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMspb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMspb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMspb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("mspb.proto", fileDescriptorMspb) }

var fileDescriptorMspb = []byte{
	// 1583 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0xcd, 0x6e, 0xdb, 0xc6,
	0x16, 0xb6, 0x64, 0x4a, 0x96, 0x8e, 0x25, 0xc5, 0x1e, 0xff, 0xc9, 0x4c, 0xe2, 0xeb, 0x30, 0x37,
	0x37, 0xbe, 0x4d, 0xe0, 0xb4, 0x6e, 0x17, 0x45, 0x0b, 0x14, 0x88, 0x13, 0xc3, 0x51, 0x51, 0x27,
	0x06, 0xe5, 0xbd, 0x40, 0x89, 0x13, 0x47, 0x30, 0xc5, 0x61, 0x38, 0x54, 0x0c, 0xef, 0x0a, 0xb4,
	0xab, 0xae, 0xba, 0x6b, 0xfb, 0x04, 0x7d, 0x89, 0x2e, 0xbb, 0xe8, 0xa6, 0x40, 0x1f, 0xa1, 0x48,
	0x5f, 0xa4, 0x98, 0x33, 0x3f, 0x22, 0x29, 0x39, 0x01, 0x98, 0xc4, 0xbb, 0x99, 0xf3, 0x37, 0xdf,
	0x39, 0xfc, 0x66, 0xe6, 0x0c, 0x01, 0x46, 0x3c, 0xea, 0xef, 0x46, 0x31, 0x4b, 0x18, 0xb1, 0xc4,
	0xd8, 0x6e, 0x8c, 0x68, 0xe2, 0x69, 0x99, 0xdd, 0xe4, 0x89, 0x97, 0xf0, 0xc9, 0x94, 0xbe, 0xa2,
	0x61, 0x62, 0xa6, 0x8d, 0xc4, 0xe3, 0x67, 0x66, 0xb6, 0x7a, 0xca, 0x4e, 0x19, 0x0e, 0x1f, 0x88,
	0x91, 0x94, 0x3a, 0xbf, 0x96, 0x60, 0xe3, 0x90, 0x26, 0x27, 0x2c, 0x62, 0x01, 0x3b, 0xbd, 0x38,
	0x88, 0xd8, 0xe0, 0x85, 0x4b, 0x5f, 0x8e, 0x29, 0x4f, 0xc8, 0x3d, 0xa8, 0xbe, 0xa0, 0x9e, 0x4f,
	0xe3, 0x76, 0x69, 0xbb, 0xb4, 0xb3, 0xb8, 0xb7, 0xb2, 0x8b, 0x70, 0x94, 0xfa, 0x09, 0xaa, 0x5c,
	0x65, 0x42, 0x56, 0xa0, 0xe2, 0xf7, 0x7b, 0x43, 0xbf, 0x5d, 0xde, 0x2e, 0xed, 0x58, 0xae, 0xe5,
	0xf7, 0x3b, 0x3e, 0xd9, 0x84, 0x5a, 0xe2, 0xf5, 0x03, 0x2a, 0xe4, 0xf3, 0x28, 0x5f, 0xc0, 0x79,
	0xc7, 0x27, 0x0f, 0xa0, 0x3e, 0x18, 0xc7, 0x3d, 0x2a, 0x16, 0x6c, 0x5b, 0x18, 0x9f, 0xec, 0xaa,
	0xe4, 0x4e, 0x84, 0x8d, 0x84, 0x52, 0x1b, 0x8c, 0x63, 0x1c, 0x39, 0x7f, 0x96, 0xa0, 0x3d, 0x8d,
	0x94, 0x47, 0x2c, 0xe4, 0x94, 0xdc, 0xcf, 0x41, 0x5d, 0xd5, 0x50, 0xa5, 0x3e, 0x87, 0xf5, 0x0e,
	0x54, 0x63, 0x36, 0x4e, 0x28, 0x6f, 0x97, 0xb7, 0xe7, 0x77, 0x16, 0xf7, 0x9a, 0x7a, 0x61, 0x57,
	0x48, 0x5d, 0xa5, 0x24, 0x3b, 0x50, 0x91, 0xf0, 0xe6, 0x2f, 0x85, 0x27, 0x0d, 0xc8, 0x1e, 0xd4,
	0xe3, 0xf3, 0x5e, 0xc4, 0x82, 0xe1, 0xe0, 0x42, 0x25, 0xb3, 0x96, 0xb1, 0x76, 0xcf, 0x8f, 0x51,
	0xe9, 0xd6, 0x62, 0x35, 0x72, 0x3e, 0x83, 0xda, 0x51, 0xf7, 0x1b, 0x09, 0xa8, 0x05, 0xe5, 0xa1,
	0x8f, 0xd0, 0x2d, 0xb7, 0x3c, 0xf4, 0x49, 0x1b, 0x16, 0x3c, 0xdf, 0x8f, 0x29, 0xe7, 0x58, 0xce,
	0xba, 0xab, 0xa7, 0xce, 0x43, 0x20, 0x87, 0x34, 0xd1, 0x8e, 0x45, 0xbe, 0x94, 0x73, 0x06, 0x2b,
	0x99, 0x10, 0x85, 0x4a, 0xf8, 0x3f, 0xa8, 0x06, 0xd2, 0xba, 0x8c, 0xd6, 0x2d, 0x69, 0x6d, 0xa2,
	0x2a, 0xad, 0x73, 0x0c, 0xf5, 0x63, 0x4a, 0xe3, 0xae, 0xe0, 0x29, 0xd9, 0x06, 0x2b, 0xa2, 0x66,
	0x81, 0x86, 0xae, 0x90, 0x30, 0x70, 0x51, 0x43, 0x6e, 0x41, 0xc3, 0x67, 0xe7, 0x61, 0x8f, 0xd3,
	0x01, 0x0b, 0x7d, 0xae, 0xc8, 0xb4, 0x28, 0x64, 0x5d, 0x29, 0x72, 0xbe, 0x9f, 0x87, 0x35, 0xd7,
	0x0b, 0x4f, 0x05, 0xa2, 0x38, 0xe9, 0x53, 0x2f, 0x29, 0xc4, 0xd7, 0xdb, 0x50, 0x89, 0x45, 0x14,
	0x85, 0x7f, 0x42, 0x01, 0x21, 0x74, 0xa5, 0x2e, 0x95, 0xe5, 0xbc, 0xce, 0x52, 0x5a, 0x65, 0xb3,
	0x24, 0xbb, 0x00, 0x08, 0x5b, 0xe4, 0xc0, 0xdb, 0x16, 0x92, 0xea, 0x9a, 0x5c, 0xdd, 0x64, 0xef,
	0xd6, 0x85, 0x89, 0x98, 0x72, 0xf2, 0x09, 0x34, 0x23, 0x1a, 0xfa, 0xc3, 0xf0, 0x54, 0xb9, 0x54,
	0xd0, 0x25, 0x5b, 0x91, 0x86, 0x32, 0x91, 0x2e, 0xdb, 0xd0, 0x08, 0x3c, 0x9e, 0xf4, 0xc4, 0x9e,
	0x16, 0xdb, 0xa9, 0x8a, 0x95, 0x01, 0x21, 0x3b, 0xf1, 0xf8, 0x59, 0xc7, 0x27, 0xab, 0x50, 0xe1,
	0x03, 0x16, 0xd3, 0xf6, 0xc2, 0x76, 0x69, 0xa7, 0xe9, 0xca, 0x09, 0xf9, 0x3f, 0x54, 0xf0, 0x90,
	0x68, 0xd7, 0x54, 0x4d, 0xf4, 0x91, 0x81, 0x89, 0x4a, 0x64, 0xd2, 0x42, 0xd4, 0x4f, 0x0c, 0xc6,
	0xbc, 0x5d, 0x9f, 0xb2, 0x7d, 0x9e, 0x74, 0x51, 0xe5, 0x2a, 0x13, 0xe7, 0xbb, 0x12, 0xac, 0xe7,
	0x3f, 0x43, 0x21, 0x26, 0x6d, 0x42, 0x0d, 0x8b, 0x3d, 0x39, 0x3b, 0x16, 0x70, 0xde, 0xf1, 0x05,
	0x5f, 0x44, 0xba, 0xaa, 0xf8, 0x8d, 0x5d, 0x75, 0x9e, 0x89, 0x7c, 0x5d, 0xd4, 0x38, 0xbf, 0x5b,
	0xb0, 0xfa, 0x94, 0xf9, 0xef, 0xc8, 0x85, 0x0d, 0x58, 0x08, 0x99, 0x9f, 0x42, 0x50, 0x15, 0xd3,
	0x8e, 0x4f, 0x3e, 0x06, 0x40, 0x85, 0xc8, 0x99, 0x22, 0x8c, 0xd6, 0xde, 0xb2, 0xfe, 0x48, 0x62,
	0x5d, 0x51, 0x14, 0xea, 0xd6, 0x43, 0x3d, 0x9c, 0xfa, 0x4c, 0xd6, 0xd4, 0x67, 0xba, 0x03, 0x2d,
	0xcc, 0x8f, 0xf7, 0xd8, 0xf3, 0xe7, 0xc1, 0x30, 0xa4, 0xf8, 0xf1, 0x2d, 0xb7, 0x29, 0xa5, 0xcf,
	0xa4, 0x90, 0xac, 0x43, 0x55, 0x0a, 0xda, 0x55, 0x54, 0xab, 0x19, 0xf9, 0x0f, 0x2c, 0xca, 0x72,
	0x0d, 0xd8, 0x38, 0x4c, 0xd4, 0xb7, 0x06, 0x14, 0x3d, 0x12, 0x12, 0xf2, 0x11, 0x2c, 0x4b, 0x03,
	0x1e, 0x05, 0xc3, 0x44, 0x99, 0xd5, 0xd0, 0xec, 0x1a, 0x2a, 0xba, 0x42, 0x2e, 0x6d, 0xef, 0x03,
	0xe1, 0x8a, 0x87, 0x3c, 0xf4, 0x22, 0x65, 0x5c, 0x47, 0xe3, 0x25, 0xa5, 0xe9, 0x86, 0x5e, 0x24,
	0xad, 0x77, 0x61, 0xc5, 0x8b, 0xa2, 0xe0, 0x22, 0x67, 0x0e, 0x68, 0xbe, 0xac, 0x55, 0x13, 0xfb,
	0xfb, 0x40, 0x24, 0x12, 0xb9, 0x4b, 0x94, 0xf9, 0xa2, 0x8c, 0x8e, 0x1a, 0xb9, 0x8d, 0xa4, 0xb5,
	0xa1, 0x6f, 0x23, 0x4d, 0xdf, 0x1d, 0x4d, 0xdf, 0xa6, 0x3a, 0x83, 0x35, 0x25, 0x75, 0xf5, 0x0d,
	0x7b, 0xbf, 0x80, 0x66, 0x14, 0xb3, 0x01, 0xe5, 0xbc, 0x27, 0x3d, 0x5a, 0xea, 0x1c, 0xd6, 0x1e,
	0xc7, 0x52, 0x2b, 0x9d, 0x1a, 0x51, 0x6a, 0xe6, 0x7c, 0x5b, 0x82, 0xb5, 0x1c, 0x8d, 0x0a, 0x71,
	0xf9, 0x52, 0x22, 0xbd, 0x9d, 0xc9, 0x3f, 0x89, 0x8b, 0xd8, 0x4b, 0xe8, 0xb9, 0x77, 0xf1, 0x6e,
	0x64, 0x26, 0x60, 0x89, 0xcb, 0x42, 0x5d, 0x1c, 0x38, 0x26, 0x77, 0x75, 0x15, 0xe5, 0xfa, 0xcb,
	0xa6, 0x26, 0xdd, 0x97, 0x41, 0xa6, 0x88, 0x04, 0xac, 0x64, 0x38, 0xa2, 0x48, 0xdb, 0x79, 0x17,
	0xc7, 0xce, 0x13, 0x68, 0x4f, 0x03, 0x2b, 0x52, 0x1e, 0xe7, 0x14, 0x88, 0x4b, 0x23, 0x16, 0x27,
	0x07, 0xa2, 0x4f, 0x29, 0x94, 0xdd, 0x7f, 0xa1, 0x82, 0x4d, 0x8e, 0xb9, 0x76, 0x74, 0xcb, 0x23,
	0x43, 0x4a, 0xa5, 0xf3, 0x08, 0x56, 0x32, 0x0b, 0x15, 0x42, 0x7b, 0x04, 0xad, 0x43, 0x9a, 0x08,
	0x5a, 0x14, 0x42, 0x2a, 0xef, 0xf4, 0xb2, 0xbe, 0xd3, 0x1d, 0x0f, 0xae, 0x99, 0x70, 0x85, 0xc8,
	0xb5, 0x0d, 0x96, 0x60, 0x93, 0xca, 0xbc, 0x91, 0x3e, 0x86, 0x5c, 0xd4, 0x38, 0xcf, 0xa0, 0x71,
	0x48, 0x93, 0xc7, 0xfb, 0x45, 0x79, 0x13, 0x7a, 0x23, 0xaa, 0x79, 0x23, 0xc6, 0x4e, 0x0f, 0x9a,
	0x2a, 0x60, 0x41, 0xc4, 0x65, 0xbf, 0xaf, 0xf0, 0x2e, 0x69, 0xbc, 0x8f, 0xbd, 0xc4, 0xdb, 0xf7,
	0x38, 0x75, 0xcb, 0x7e, 0xdf, 0x89, 0xb1, 0x28, 0xb2, 0x45, 0x7a, 0x6f, 0x5d, 0xe7, 0x4d, 0x00,
	0xd9, 0x75, 0x62, 0x3e, 0xf3, 0x98, 0x4f, 0x1d, 0x25, 0x4f, 0x45, 0x52, 0x31, 0xf6, 0x3f, 0xb8,
	0xe6, 0xfe, 0x45, 0xc7, 0xbf, 0x8a, 0x6e, 0xd7, 0xa1, 0xb0, 0x34, 0xc9, 0xb3, 0x50, 0x2d, 0x6f,
	0x43, 0x05, 0x83, 0xe5, 0xfb, 0x15, 0x19, 0x53, 0xea, 0x9c, 0x21, 0xac, 0x66, 0x53, 0xfb, 0x70,
	0x4b, 0x45, 0xb0, 0x7c, 0x48, 0x93, 0x47, 0x2c, 0x18, 0x8f, 0x42, 0x7e, 0x25, 0x35, 0x0c, 0xb0,
	0xf5, 0x35, 0x2b, 0x16, 0x4a, 0x6d, 0x07, 0x16, 0x06, 0x32, 0x80, 0x6a, 0xfd, 0x4d, 0x47, 0x27,
	0xe3, 0xba, 0x5a, 0xed, 0xfc, 0x58, 0x82, 0x75, 0xb3, 0xdc, 0xfe, 0x85, 0x60, 0xce, 0x95, 0xbc,
	0x8b, 0x36, 0xa1, 0x36, 0x60, 0x81, 0xa4, 0xae, 0x25, 0x7b, 0xff, 0x01, 0x0b, 0x90, 0xb8, 0x0c,
	0x9f, 0x6a, 0x59, 0x44, 0x45, 0x9b, 0x77, 0x99, 0xe6, 0xa4, 0x79, 0xcf, 0x14, 0x41, 0x69, 0x9d,
	0x1f, 0x4a, 0xc8, 0x27, 0xbd, 0xe2, 0xd5, 0xec, 0x15, 0xb2, 0x86, 0xe8, 0x26, 0xcd, 0x53, 0x65,
	0xc0, 0x82, 0x8e, 0xef, 0x8c, 0x60, 0x2d, 0x87, 0xe5, 0x83, 0xe6, 0xfe, 0x4b, 0x09, 0x96, 0x1e,
	0xfa, 0xbe, 0x92, 0x5e, 0x45, 0xde, 0x29, 0x6e, 0x5a, 0x6f, 0xe6, 0xe6, 0x19, 0x2c, 0xa7, 0xa0,
	0x7d, 0xe0, 0x8d, 0xc0, 0x61, 0xf5, 0x24, 0x1e, 0x87, 0x03, 0x2f, 0xa1, 0xef, 0xf9, 0x9c, 0x7e,
	0xc3, 0x5e, 0x3f, 0x80, 0xb5, 0xdc, 0xa2, 0x85, 0xae, 0xf0, 0x5d, 0x68, 0x66, 0xf0, 0x88, 0xab,
	0x61, 0x10, 0x8c, 0x79, 0x42, 0xe3, 0x9e, 0x79, 0x70, 0xd7, 0x95, 0xa4, 0xe3, 0x3b, 0x2e, 0xb4,
	0xb2, 0x91, 0xde, 0xe2, 0x40, 0x6e, 0x41, 0x85, 0xc6, 0x31, 0xd3, 0xaf, 0xe0, 0x45, 0x89, 0xe6,
	0x40, 0x88, 0x5c, 0xa9, 0x71, 0xee, 0x42, 0xed, 0x88, 0xab, 0x77, 0xfe, 0x75, 0xa8, 0x8f, 0xb8,
	0x6a, 0x87, 0x31, 0x58, 0xdd, 0xad, 0x8d, 0x94, 0xd2, 0x01, 0xa8, 0x3d, 0x65, 0x6a, 0xec, 0x41,
	0x05, 0x83, 0x90, 0x7b, 0x69, 0x8f, 0xec, 0x53, 0x5b, 0xf9, 0x4d, 0x22, 0x08, 0xe3, 0x90, 0xf5,
	0xf2, 0x2f, 0x56, 0xd9, 0x2d, 0x6b, 0xe3, 0x50, 0x8d, 0xf6, 0x7e, 0xab, 0x09, 0x60, 0x5d, 0x1a,
	0xbf, 0xa2, 0x31, 0xe9, 0xc2, 0x52, 0xbe, 0xc7, 0x23, 0x37, 0xa5, 0xeb, 0x25, 0x4d, 0xa9, 0xbd,
	0x75, 0x99, 0x5a, 0xd6, 0xcf, 0x99, 0x23, 0x5f, 0x43, 0x33, 0xd3, 0x54, 0x13, 0x5b, 0x83, 0x99,
	0x7e, 0xb0, 0xd9, 0xd7, 0x67, 0xea, 0x4c, 0xac, 0x23, 0x68, 0x65, 0x5f, 0x9b, 0x44, 0x39, 0xcc,
	0xfc, 0x15, 0x60, 0xdf, 0x98, 0xad, 0x34, 0xe1, 0x1e, 0xc3, 0x62, 0xaa, 0x41, 0x24, 0x6d, 0xcd,
	0xa2, 0x7c, 0x73, 0x6a, 0x6f, 0xce, 0xd0, 0x98, 0x28, 0x5d, 0x79, 0xab, 0xa7, 0xff, 0x48, 0x99,
	0xaa, 0xcd, 0xfe, 0xa7, 0x66, 0xaa, 0x76, 0xc9, 0x8f, 0x2c, 0x67, 0x8e, 0x7c, 0x0e, 0x0b, 0xaa,
	0x4f, 0x24, 0xab, 0xc6, 0x38, 0xd5, 0x85, 0xda, 0x6b, 0x39, 0xa9, 0xf1, 0xdc, 0x83, 0x0a, 0x76,
	0x6b, 0x84, 0x18, 0x0b, 0xd3, 0x0b, 0xda, 0x2b, 0x19, 0x99, 0xf1, 0xf9, 0x12, 0x6a, 0xba, 0x63,
	0x20, 0x93, 0xc0, 0xe9, 0x8d, 0x6e, 0xaf, 0xe7, 0xc5, 0xc6, 0xf9, 0x10, 0xfb, 0x4d, 0xd3, 0x6e,
	0x90, 0xcd, 0xac, 0x65, 0xea, 0xc6, 0xb0, 0xed, 0x59, 0x2a, 0x13, 0xe8, 0x21, 0xc0, 0xe4, 0x6a,
	0x27, 0x1b, 0xc6, 0x36, 0xdb, 0x5e, 0xd8, 0xed, 0x69, 0x85, 0x09, 0x71, 0x8c, 0x9d, 0x64, 0xfa,
	0x72, 0x24, 0x37, 0x72, 0xe6, 0x99, 0x5b, 0xdc, 0xbe, 0x79, 0x89, 0x36, 0x4d, 0xdf, 0xcc, 0x85,
	0x43, 0xec, 0x29, 0x8f, 0x49, 0x7e, 0xd7, 0x67, 0xea, 0xd2, 0x7c, 0x4b, 0xfd, 0x73, 0x23, 0x93,
	0x44, 0x72, 0x7f, 0xf2, 0xec, 0xcd, 0x19, 0x9a, 0x34, 0xa2, 0xcc, 0xa9, 0xa8, 0x11, 0xcd, 0x3a,
	0x9f, 0x35, 0xa2, 0x99, 0xc7, 0xa8, 0x33, 0x47, 0xbe, 0x82, 0xba, 0xb9, 0x43, 0x88, 0xfa, 0xc4,
	0xf9, 0xfb, 0xce, 0xde, 0x98, 0x92, 0x6b, 0xff, 0xfd, 0xa5, 0x3f, 0x5e, 0x6f, 0x95, 0xfe, 0x7a,
	0xbd, 0x55, 0xfa, 0xfb, 0xf5, 0x56, 0xe9, 0xe7, 0x7f, 0xb6, 0xe6, 0xfa, 0x55, 0xfc, 0xa3, 0xfc,
	0xe9, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x38, 0x34, 0xb3, 0x40, 0xb5, 0x16, 0x00, 0x00,
}
