// Code generated by protoc-gen-gogo.
// source: statspb.proto
// DO NOT EDIT!

/*
	Package statspb is a generated protocol buffer package.

	It is generated from these files:
		statspb.proto

	It has these top-level messages:
		ClusterStats
		DataBaseStats
		TableStats
		ProcessStats
		NodeStats
		RangeStats
		ReplicaStatus
		RaftStatus
		SqlStats
		SqlSlowlog
		SqlSlow
		SqlTp
*/
package statspb

import (
	"fmt"
	"io"
	"math"

	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TpArgs int32

const (
	TpArgs_invalid    TpArgs = 0
	TpArgs_msec_index TpArgs = 1000
	TpArgs_sec_index  TpArgs = 1060
	TpArgs_min_index  TpArgs = 1061
)

var TpArgs_name = map[int32]string{
	0:    "invalid",
	1000: "msec_index",
	1060: "sec_index",
	1061: "min_index",
}
var TpArgs_value = map[string]int32{
	"invalid":    0,
	"msec_index": 1000,
	"sec_index":  1060,
	"min_index":  1061,
}

func (x TpArgs) String() string {
	return proto.EnumName(TpArgs_name, int32(x))
}
func (TpArgs) EnumDescriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{0} }

type ClusterStats struct {
}

func (m *ClusterStats) Reset()                    { *m = ClusterStats{} }
func (m *ClusterStats) String() string            { return proto.CompactTextString(m) }
func (*ClusterStats) ProtoMessage()               {}
func (*ClusterStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{0} }

type DataBaseStats struct {
}

func (m *DataBaseStats) Reset()                    { *m = DataBaseStats{} }
func (m *DataBaseStats) String() string            { return proto.CompactTextString(m) }
func (*DataBaseStats) ProtoMessage()               {}
func (*DataBaseStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{1} }

type TableStats struct {
}

func (m *TableStats) Reset()                    { *m = TableStats{} }
func (m *TableStats) String() string            { return proto.CompactTextString(m) }
func (*TableStats) ProtoMessage()               {}
func (*TableStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{2} }

type ProcessStats struct {
	CpuPercent         float64 `protobuf:"fixed64,1,opt,name=cpu_percent,json=cpuPercent,proto3" json:"cpu_percent,omitempty"`
	IoReadCount        uint64  `protobuf:"varint,2,opt,name=io_read_count,json=ioReadCount,proto3" json:"io_read_count,omitempty"`
	IoWriteCount       uint64  `protobuf:"varint,3,opt,name=io_write_count,json=ioWriteCount,proto3" json:"io_write_count,omitempty"`
	IoReadBytes        uint64  `protobuf:"varint,4,opt,name=io_read_bytes,json=ioReadBytes,proto3" json:"io_read_bytes,omitempty"`
	IoWriteBytes       uint64  `protobuf:"varint,5,opt,name=io_write_bytes,json=ioWriteBytes,proto3" json:"io_write_bytes,omitempty"`
	MemoryRss          uint64  `protobuf:"varint,6,opt,name=memory_rss,json=memoryRss,proto3" json:"memory_rss,omitempty"`
	MemoryVms          uint64  `protobuf:"varint,7,opt,name=memory_vms,json=memoryVms,proto3" json:"memory_vms,omitempty"`
	MemorySwap         uint64  `protobuf:"varint,8,opt,name=memory_swap,json=memorySwap,proto3" json:"memory_swap,omitempty"`
	MemoryPercent      float64 `protobuf:"fixed64,9,opt,name=memory_percent,json=memoryPercent,proto3" json:"memory_percent,omitempty"`
	NetConnectionCount uint64  `protobuf:"varint,10,opt,name=net_connection_count,json=netConnectionCount,proto3" json:"net_connection_count,omitempty"`
	NetByteSent        uint64  `protobuf:"varint,11,opt,name=net_byte_sent,json=netByteSent,proto3" json:"net_byte_sent,omitempty"`
	NetByteRecv        uint64  `protobuf:"varint,12,opt,name=net_byte_recv,json=netByteRecv,proto3" json:"net_byte_recv,omitempty"`
	NetPacketSent      uint64  `protobuf:"varint,13,opt,name=net_packet_sent,json=netPacketSent,proto3" json:"net_packet_sent,omitempty"`
	NetPacketRecv      uint64  `protobuf:"varint,14,opt,name=net_packet_recv,json=netPacketRecv,proto3" json:"net_packet_recv,omitempty"`
	NetErrIn           uint64  `protobuf:"varint,15,opt,name=net_err_in,json=netErrIn,proto3" json:"net_err_in,omitempty"`
	NetErrOut          uint64  `protobuf:"varint,16,opt,name=net_err_out,json=netErrOut,proto3" json:"net_err_out,omitempty"`
	NetDropIn          uint64  `protobuf:"varint,17,opt,name=net_drop_in,json=netDropIn,proto3" json:"net_drop_in,omitempty"`
	NetDropOut         uint64  `protobuf:"varint,18,opt,name=net_drop_out,json=netDropOut,proto3" json:"net_drop_out,omitempty"`
}

func (m *ProcessStats) Reset()                    { *m = ProcessStats{} }
func (m *ProcessStats) String() string            { return proto.CompactTextString(m) }
func (*ProcessStats) ProtoMessage()               {}
func (*ProcessStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{3} }

func (m *ProcessStats) GetCpuPercent() float64 {
	if m != nil {
		return m.CpuPercent
	}
	return 0
}

func (m *ProcessStats) GetIoReadCount() uint64 {
	if m != nil {
		return m.IoReadCount
	}
	return 0
}

func (m *ProcessStats) GetIoWriteCount() uint64 {
	if m != nil {
		return m.IoWriteCount
	}
	return 0
}

func (m *ProcessStats) GetIoReadBytes() uint64 {
	if m != nil {
		return m.IoReadBytes
	}
	return 0
}

func (m *ProcessStats) GetIoWriteBytes() uint64 {
	if m != nil {
		return m.IoWriteBytes
	}
	return 0
}

func (m *ProcessStats) GetMemoryRss() uint64 {
	if m != nil {
		return m.MemoryRss
	}
	return 0
}

func (m *ProcessStats) GetMemoryVms() uint64 {
	if m != nil {
		return m.MemoryVms
	}
	return 0
}

func (m *ProcessStats) GetMemorySwap() uint64 {
	if m != nil {
		return m.MemorySwap
	}
	return 0
}

func (m *ProcessStats) GetMemoryPercent() float64 {
	if m != nil {
		return m.MemoryPercent
	}
	return 0
}

func (m *ProcessStats) GetNetConnectionCount() uint64 {
	if m != nil {
		return m.NetConnectionCount
	}
	return 0
}

func (m *ProcessStats) GetNetByteSent() uint64 {
	if m != nil {
		return m.NetByteSent
	}
	return 0
}

func (m *ProcessStats) GetNetByteRecv() uint64 {
	if m != nil {
		return m.NetByteRecv
	}
	return 0
}

func (m *ProcessStats) GetNetPacketSent() uint64 {
	if m != nil {
		return m.NetPacketSent
	}
	return 0
}

func (m *ProcessStats) GetNetPacketRecv() uint64 {
	if m != nil {
		return m.NetPacketRecv
	}
	return 0
}

func (m *ProcessStats) GetNetErrIn() uint64 {
	if m != nil {
		return m.NetErrIn
	}
	return 0
}

func (m *ProcessStats) GetNetErrOut() uint64 {
	if m != nil {
		return m.NetErrOut
	}
	return 0
}

func (m *ProcessStats) GetNetDropIn() uint64 {
	if m != nil {
		return m.NetDropIn
	}
	return 0
}

func (m *ProcessStats) GetNetDropOut() uint64 {
	if m != nil {
		return m.NetDropOut
	}
	return 0
}

type NodeStats struct {
	// Memory
	MemoryTotal           uint64  `protobuf:"varint,1,opt,name=memory_total,json=memoryTotal,proto3" json:"memory_total,omitempty"`
	MemoryUsedRss         uint64  `protobuf:"varint,2,opt,name=memory_used_rss,json=memoryUsedRss,proto3" json:"memory_used_rss,omitempty"`
	MemoryUsed            uint64  `protobuf:"varint,3,opt,name=memory_used,json=memoryUsed,proto3" json:"memory_used,omitempty"`
	MemoryFree            uint64  `protobuf:"varint,4,opt,name=memory_free,json=memoryFree,proto3" json:"memory_free,omitempty"`
	MemoryUsedPercent     float64 `protobuf:"fixed64,5,opt,name=memory_used_percent,json=memoryUsedPercent,proto3" json:"memory_used_percent,omitempty"`
	SwapMemoryTotal       uint64  `protobuf:"varint,6,opt,name=swap_memory_total,json=swapMemoryTotal,proto3" json:"swap_memory_total,omitempty"`
	SwapMemoryUsed        uint64  `protobuf:"varint,7,opt,name=swap_memory_used,json=swapMemoryUsed,proto3" json:"swap_memory_used,omitempty"`
	SwapMemoryFree        uint64  `protobuf:"varint,8,opt,name=swap_memory_free,json=swapMemoryFree,proto3" json:"swap_memory_free,omitempty"`
	SwapMemoryUsedPercent float64 `protobuf:"fixed64,9,opt,name=swap_memory_used_percent,json=swapMemoryUsedPercent,proto3" json:"swap_memory_used_percent,omitempty"`
	// CPU
	CpuProcRate float64 `protobuf:"fixed64,10,opt,name=cpu_proc_rate,json=cpuProcRate,proto3" json:"cpu_proc_rate,omitempty"`
	CpuCount    uint32  `protobuf:"varint,11,opt,name=cpu_count,json=cpuCount,proto3" json:"cpu_count,omitempty"`
	Load1       float64 `protobuf:"fixed64,12,opt,name=load1,proto3" json:"load1,omitempty"`
	Load5       float64 `protobuf:"fixed64,13,opt,name=load5,proto3" json:"load5,omitempty"`
	Load15      float64 `protobuf:"fixed64,14,opt,name=load15,proto3" json:"load15,omitempty"`
	// Disk
	DiskTotal    uint64  `protobuf:"varint,15,opt,name=disk_total,json=diskTotal,proto3" json:"disk_total,omitempty"`
	DiskUsed     uint64  `protobuf:"varint,16,opt,name=disk_used,json=diskUsed,proto3" json:"disk_used,omitempty"`
	DiskFree     uint64  `protobuf:"varint,17,opt,name=disk_free,json=diskFree,proto3" json:"disk_free,omitempty"`
	DiskProcRate float64 `protobuf:"fixed64,18,opt,name=disk_proc_rate,json=diskProcRate,proto3" json:"disk_proc_rate,omitempty"`
	//    float disk_busy                          = 19;
	DiskReadBytePerSec  uint64 `protobuf:"varint,20,opt,name=disk_read_byte_per_sec,json=diskReadBytePerSec,proto3" json:"disk_read_byte_per_sec,omitempty"`
	DiskWriteBytePerSec uint64 `protobuf:"varint,21,opt,name=disk_write_byte_per_sec,json=diskWriteBytePerSec,proto3" json:"disk_write_byte_per_sec,omitempty"`
	//    uint64 disk_read_count_per_sec           = 22;
	//    uint64 disk_write_count_per_sec          = 23;
	// Net
	NetIoInBytePerSec  uint64 `protobuf:"varint,24,opt,name=net_io_in_byte_per_sec,json=netIoInBytePerSec,proto3" json:"net_io_in_byte_per_sec,omitempty"`
	NetIoOutBytePerSec uint64 `protobuf:"varint,25,opt,name=net_io_out_byte_per_sec,json=netIoOutBytePerSec,proto3" json:"net_io_out_byte_per_sec,omitempty"`
	//    uint64 net_io_in_package_per_sec         = 26;
	//    uint64 net_io_out_package_per_sec        = 27;
	NetTcpConnections       uint32 `protobuf:"varint,28,opt,name=net_tcp_connections,json=netTcpConnections,proto3" json:"net_tcp_connections,omitempty"`
	NetTcpActiveOpensPerSec uint64 `protobuf:"varint,29,opt,name=net_tcp_active_opens_per_sec,json=netTcpActiveOpensPerSec,proto3" json:"net_tcp_active_opens_per_sec,omitempty"`
	// server
	Ops uint64 `protobuf:"varint,37,opt,name=ops,proto3" json:"ops,omitempty"`
	// Total range count in this store.
	//    uint64 range_count              = 38;
	// Current range split count.
	RangeSplitCount uint32 `protobuf:"varint,39,opt,name=range_split_count,json=rangeSplitCount,proto3" json:"range_split_count,omitempty"`
	// Current sending snapshot count.
	SendingSnapCount uint32 `protobuf:"varint,40,opt,name=sending_snap_count,json=sendingSnapCount,proto3" json:"sending_snap_count,omitempty"`
	// Current receiving snapshot count.
	ReceivingSnapCount uint32 `protobuf:"varint,41,opt,name=receiving_snap_count,json=receivingSnapCount,proto3" json:"receiving_snap_count,omitempty"`
	// How many range is applying snapshot.
	ApplyingSnapCount uint32 `protobuf:"varint,42,opt,name=applying_snap_count,json=applyingSnapCount,proto3" json:"applying_snap_count,omitempty"`
	// When the data server is started (unix timestamp in seconds).
	StartTime uint32 `protobuf:"varint,44,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
}

func (m *NodeStats) Reset()                    { *m = NodeStats{} }
func (m *NodeStats) String() string            { return proto.CompactTextString(m) }
func (*NodeStats) ProtoMessage()               {}
func (*NodeStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{4} }

func (m *NodeStats) GetMemoryTotal() uint64 {
	if m != nil {
		return m.MemoryTotal
	}
	return 0
}

func (m *NodeStats) GetMemoryUsedRss() uint64 {
	if m != nil {
		return m.MemoryUsedRss
	}
	return 0
}

func (m *NodeStats) GetMemoryUsed() uint64 {
	if m != nil {
		return m.MemoryUsed
	}
	return 0
}

func (m *NodeStats) GetMemoryFree() uint64 {
	if m != nil {
		return m.MemoryFree
	}
	return 0
}

func (m *NodeStats) GetMemoryUsedPercent() float64 {
	if m != nil {
		return m.MemoryUsedPercent
	}
	return 0
}

func (m *NodeStats) GetSwapMemoryTotal() uint64 {
	if m != nil {
		return m.SwapMemoryTotal
	}
	return 0
}

func (m *NodeStats) GetSwapMemoryUsed() uint64 {
	if m != nil {
		return m.SwapMemoryUsed
	}
	return 0
}

func (m *NodeStats) GetSwapMemoryFree() uint64 {
	if m != nil {
		return m.SwapMemoryFree
	}
	return 0
}

func (m *NodeStats) GetSwapMemoryUsedPercent() float64 {
	if m != nil {
		return m.SwapMemoryUsedPercent
	}
	return 0
}

func (m *NodeStats) GetCpuProcRate() float64 {
	if m != nil {
		return m.CpuProcRate
	}
	return 0
}

func (m *NodeStats) GetCpuCount() uint32 {
	if m != nil {
		return m.CpuCount
	}
	return 0
}

func (m *NodeStats) GetLoad1() float64 {
	if m != nil {
		return m.Load1
	}
	return 0
}

func (m *NodeStats) GetLoad5() float64 {
	if m != nil {
		return m.Load5
	}
	return 0
}

func (m *NodeStats) GetLoad15() float64 {
	if m != nil {
		return m.Load15
	}
	return 0
}

func (m *NodeStats) GetDiskTotal() uint64 {
	if m != nil {
		return m.DiskTotal
	}
	return 0
}

func (m *NodeStats) GetDiskUsed() uint64 {
	if m != nil {
		return m.DiskUsed
	}
	return 0
}

func (m *NodeStats) GetDiskFree() uint64 {
	if m != nil {
		return m.DiskFree
	}
	return 0
}

func (m *NodeStats) GetDiskProcRate() float64 {
	if m != nil {
		return m.DiskProcRate
	}
	return 0
}

func (m *NodeStats) GetDiskReadBytePerSec() uint64 {
	if m != nil {
		return m.DiskReadBytePerSec
	}
	return 0
}

func (m *NodeStats) GetDiskWriteBytePerSec() uint64 {
	if m != nil {
		return m.DiskWriteBytePerSec
	}
	return 0
}

func (m *NodeStats) GetNetIoInBytePerSec() uint64 {
	if m != nil {
		return m.NetIoInBytePerSec
	}
	return 0
}

func (m *NodeStats) GetNetIoOutBytePerSec() uint64 {
	if m != nil {
		return m.NetIoOutBytePerSec
	}
	return 0
}

func (m *NodeStats) GetNetTcpConnections() uint32 {
	if m != nil {
		return m.NetTcpConnections
	}
	return 0
}

func (m *NodeStats) GetNetTcpActiveOpensPerSec() uint64 {
	if m != nil {
		return m.NetTcpActiveOpensPerSec
	}
	return 0
}

func (m *NodeStats) GetOps() uint64 {
	if m != nil {
		return m.Ops
	}
	return 0
}

func (m *NodeStats) GetRangeSplitCount() uint32 {
	if m != nil {
		return m.RangeSplitCount
	}
	return 0
}

func (m *NodeStats) GetSendingSnapCount() uint32 {
	if m != nil {
		return m.SendingSnapCount
	}
	return 0
}

func (m *NodeStats) GetReceivingSnapCount() uint32 {
	if m != nil {
		return m.ReceivingSnapCount
	}
	return 0
}

func (m *NodeStats) GetApplyingSnapCount() uint32 {
	if m != nil {
		return m.ApplyingSnapCount
	}
	return 0
}

func (m *NodeStats) GetStartTime() uint32 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

type RangeStats struct {
	Size_                  uint64 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	Ops                    uint64 `protobuf:"varint,2,opt,name=ops,proto3" json:"ops,omitempty"`
	BytesInPerSec          uint64 `protobuf:"varint,3,opt,name=bytes_in_per_sec,json=bytesInPerSec,proto3" json:"bytes_in_per_sec,omitempty"`
	BytesOutPerSec         uint64 `protobuf:"varint,4,opt,name=bytes_out_per_sec,json=bytesOutPerSec,proto3" json:"bytes_out_per_sec,omitempty"`
	TotalCommandsProcessed uint64 `protobuf:"varint,5,opt,name=total_commands_processed,json=totalCommandsProcessed,proto3" json:"total_commands_processed,omitempty"`
	KeyspaceMisses         uint64 `protobuf:"varint,6,opt,name=keyspace_misses,json=keyspaceMisses,proto3" json:"keyspace_misses,omitempty"`
}

func (m *RangeStats) Reset()                    { *m = RangeStats{} }
func (m *RangeStats) String() string            { return proto.CompactTextString(m) }
func (*RangeStats) ProtoMessage()               {}
func (*RangeStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{5} }

func (m *RangeStats) GetSize_() uint64 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *RangeStats) GetOps() uint64 {
	if m != nil {
		return m.Ops
	}
	return 0
}

func (m *RangeStats) GetBytesInPerSec() uint64 {
	if m != nil {
		return m.BytesInPerSec
	}
	return 0
}

func (m *RangeStats) GetBytesOutPerSec() uint64 {
	if m != nil {
		return m.BytesOutPerSec
	}
	return 0
}

func (m *RangeStats) GetTotalCommandsProcessed() uint64 {
	if m != nil {
		return m.TotalCommandsProcessed
	}
	return 0
}

func (m *RangeStats) GetKeyspaceMisses() uint64 {
	if m != nil {
		return m.KeyspaceMisses
	}
	return 0
}

type ReplicaStatus struct {
	Match       uint64 `protobuf:"varint,1,opt,name=Match,proto3" json:"Match,omitempty"`
	Commit      uint64 `protobuf:"varint,2,opt,name=Commit,proto3" json:"Commit,omitempty"`
	Next        uint64 `protobuf:"varint,3,opt,name=Next,proto3" json:"Next,omitempty"`
	State       string `protobuf:"bytes,4,opt,name=State,proto3" json:"State,omitempty"`
	Snapshoting bool   `protobuf:"varint,5,opt,name=Snapshoting,proto3" json:"Snapshoting,omitempty"`
	Paused      bool   `protobuf:"varint,6,opt,name=Paused,proto3" json:"Paused,omitempty"`
	Active      bool   `protobuf:"varint,7,opt,name=Active,proto3" json:"Active,omitempty"`
	LastActive  int64  `protobuf:"varint,8,opt,name=LastActive,proto3" json:"LastActive,omitempty"`
	Inflight    int32  `protobuf:"varint,9,opt,name=Inflight,proto3" json:"Inflight,omitempty"`
	ID          uint64 `protobuf:"varint,10,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *ReplicaStatus) Reset()                    { *m = ReplicaStatus{} }
func (m *ReplicaStatus) String() string            { return proto.CompactTextString(m) }
func (*ReplicaStatus) ProtoMessage()               {}
func (*ReplicaStatus) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{6} }

func (m *ReplicaStatus) GetMatch() uint64 {
	if m != nil {
		return m.Match
	}
	return 0
}

func (m *ReplicaStatus) GetCommit() uint64 {
	if m != nil {
		return m.Commit
	}
	return 0
}

func (m *ReplicaStatus) GetNext() uint64 {
	if m != nil {
		return m.Next
	}
	return 0
}

func (m *ReplicaStatus) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *ReplicaStatus) GetSnapshoting() bool {
	if m != nil {
		return m.Snapshoting
	}
	return false
}

func (m *ReplicaStatus) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

func (m *ReplicaStatus) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *ReplicaStatus) GetLastActive() int64 {
	if m != nil {
		return m.LastActive
	}
	return 0
}

func (m *ReplicaStatus) GetInflight() int32 {
	if m != nil {
		return m.Inflight
	}
	return 0
}

func (m *ReplicaStatus) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type RaftStatus struct {
	ID                uint64           `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	NodeID            uint64           `protobuf:"varint,2,opt,name=NodeID,proto3" json:"NodeID,omitempty"`
	Leader            uint64           `protobuf:"varint,3,opt,name=Leader,proto3" json:"Leader,omitempty"`
	Term              uint64           `protobuf:"varint,4,opt,name=Term,proto3" json:"Term,omitempty"`
	Index             uint64           `protobuf:"varint,5,opt,name=Index,proto3" json:"Index,omitempty"`
	Commit            uint64           `protobuf:"varint,6,opt,name=Commit,proto3" json:"Commit,omitempty"`
	Applied           uint64           `protobuf:"varint,7,opt,name=Applied,proto3" json:"Applied,omitempty"`
	Vote              uint64           `protobuf:"varint,8,opt,name=Vote,proto3" json:"Vote,omitempty"`
	PendQueue         int32            `protobuf:"varint,9,opt,name=PendQueue,proto3" json:"PendQueue,omitempty"`
	RecvQueue         int32            `protobuf:"varint,10,opt,name=RecvQueue,proto3" json:"RecvQueue,omitempty"`
	AppQueue          int32            `protobuf:"varint,11,opt,name=AppQueue,proto3" json:"AppQueue,omitempty"`
	Stopped           bool             `protobuf:"varint,12,opt,name=Stopped,proto3" json:"Stopped,omitempty"`
	RestoringSnapshot bool             `protobuf:"varint,13,opt,name=RestoringSnapshot,proto3" json:"RestoringSnapshot,omitempty"`
	State             string           `protobuf:"bytes,14,opt,name=State,proto3" json:"State,omitempty"`
	Replicas          []*ReplicaStatus `protobuf:"bytes,15,rep,name=Replicas" json:"Replicas,omitempty"`
}

func (m *RaftStatus) Reset()                    { *m = RaftStatus{} }
func (m *RaftStatus) String() string            { return proto.CompactTextString(m) }
func (*RaftStatus) ProtoMessage()               {}
func (*RaftStatus) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{7} }

func (m *RaftStatus) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RaftStatus) GetNodeID() uint64 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *RaftStatus) GetLeader() uint64 {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *RaftStatus) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *RaftStatus) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *RaftStatus) GetCommit() uint64 {
	if m != nil {
		return m.Commit
	}
	return 0
}

func (m *RaftStatus) GetApplied() uint64 {
	if m != nil {
		return m.Applied
	}
	return 0
}

func (m *RaftStatus) GetVote() uint64 {
	if m != nil {
		return m.Vote
	}
	return 0
}

func (m *RaftStatus) GetPendQueue() int32 {
	if m != nil {
		return m.PendQueue
	}
	return 0
}

func (m *RaftStatus) GetRecvQueue() int32 {
	if m != nil {
		return m.RecvQueue
	}
	return 0
}

func (m *RaftStatus) GetAppQueue() int32 {
	if m != nil {
		return m.AppQueue
	}
	return 0
}

func (m *RaftStatus) GetStopped() bool {
	if m != nil {
		return m.Stopped
	}
	return false
}

func (m *RaftStatus) GetRestoringSnapshot() bool {
	if m != nil {
		return m.RestoringSnapshot
	}
	return false
}

func (m *RaftStatus) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *RaftStatus) GetReplicas() []*ReplicaStatus {
	if m != nil {
		return m.Replicas
	}
	return nil
}

type SqlStats struct {
	Ops      int64  `protobuf:"varint,1,opt,name=ops,proto3" json:"ops,omitempty"`
	DelayAvg int64  `protobuf:"varint,2,opt,name=delay_avg,json=delayAvg,proto3" json:"delay_avg,omitempty"`
	Tp       []byte `protobuf:"bytes,3,opt,name=tp,proto3" json:"tp,omitempty"`
}

func (m *SqlStats) Reset()                    { *m = SqlStats{} }
func (m *SqlStats) String() string            { return proto.CompactTextString(m) }
func (*SqlStats) ProtoMessage()               {}
func (*SqlStats) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{8} }

func (m *SqlStats) GetOps() int64 {
	if m != nil {
		return m.Ops
	}
	return 0
}

func (m *SqlStats) GetDelayAvg() int64 {
	if m != nil {
		return m.DelayAvg
	}
	return 0
}

func (m *SqlStats) GetTp() []byte {
	if m != nil {
		return m.Tp
	}
	return nil
}

type SqlSlowlog struct {
	Len  uint32     `protobuf:"varint,1,opt,name=len,proto3" json:"len,omitempty"`
	Than int32      `protobuf:"varint,2,opt,name=than,proto3" json:"than,omitempty"`
	Idx  uint32     `protobuf:"varint,3,opt,name=idx,proto3" json:"idx,omitempty"`
	Log  []*SqlSlow `protobuf:"bytes,4,rep,name=log" json:"log,omitempty"`
}

func (m *SqlSlowlog) Reset()                    { *m = SqlSlowlog{} }
func (m *SqlSlowlog) String() string            { return proto.CompactTextString(m) }
func (*SqlSlowlog) ProtoMessage()               {}
func (*SqlSlowlog) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{9} }

func (m *SqlSlowlog) GetLen() uint32 {
	if m != nil {
		return m.Len
	}
	return 0
}

func (m *SqlSlowlog) GetThan() int32 {
	if m != nil {
		return m.Than
	}
	return 0
}

func (m *SqlSlowlog) GetIdx() uint32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *SqlSlowlog) GetLog() []*SqlSlow {
	if m != nil {
		return m.Log
	}
	return nil
}

type SqlSlow struct {
	TimeSec   int64  `protobuf:"varint,1,opt,name=time_sec,json=timeSec,proto3" json:"time_sec,omitempty"`
	Sql       string `protobuf:"bytes,2,opt,name=sql,proto3" json:"sql,omitempty"`
	TotalUsec int64  `protobuf:"varint,3,opt,name=total_usec,json=totalUsec,proto3" json:"total_usec,omitempty"`
	CallUsec  int64  `protobuf:"varint,4,opt,name=call_usec,json=callUsec,proto3" json:"call_usec,omitempty"`
}

func (m *SqlSlow) Reset()                    { *m = SqlSlow{} }
func (m *SqlSlow) String() string            { return proto.CompactTextString(m) }
func (*SqlSlow) ProtoMessage()               {}
func (*SqlSlow) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{10} }

func (m *SqlSlow) GetTimeSec() int64 {
	if m != nil {
		return m.TimeSec
	}
	return 0
}

func (m *SqlSlow) GetSql() string {
	if m != nil {
		return m.Sql
	}
	return ""
}

func (m *SqlSlow) GetTotalUsec() int64 {
	if m != nil {
		return m.TotalUsec
	}
	return 0
}

func (m *SqlSlow) GetCallUsec() int64 {
	if m != nil {
		return m.CallUsec
	}
	return 0
}

type SqlTp struct {
	Calls    int64   `protobuf:"varint,1,opt,name=calls,proto3" json:"calls,omitempty"`
	Tp       []int64 `protobuf:"varint,2,rep,packed,name=tp" json:"tp,omitempty"`
	DelayMax int64   `protobuf:"varint,3,opt,name=delay_max,json=delayMax,proto3" json:"delay_max,omitempty"`
}

func (m *SqlTp) Reset()                    { *m = SqlTp{} }
func (m *SqlTp) String() string            { return proto.CompactTextString(m) }
func (*SqlTp) ProtoMessage()               {}
func (*SqlTp) Descriptor() ([]byte, []int) { return fileDescriptorStatspb, []int{11} }

func (m *SqlTp) GetCalls() int64 {
	if m != nil {
		return m.Calls
	}
	return 0
}

func (m *SqlTp) GetTp() []int64 {
	if m != nil {
		return m.Tp
	}
	return nil
}

func (m *SqlTp) GetDelayMax() int64 {
	if m != nil {
		return m.DelayMax
	}
	return 0
}

func init() {
	proto.RegisterType((*ClusterStats)(nil), "statspb.ClusterStats")
	proto.RegisterType((*DataBaseStats)(nil), "statspb.DataBaseStats")
	proto.RegisterType((*TableStats)(nil), "statspb.TableStats")
	proto.RegisterType((*ProcessStats)(nil), "statspb.ProcessStats")
	proto.RegisterType((*NodeStats)(nil), "statspb.NodeStats")
	proto.RegisterType((*RangeStats)(nil), "statspb.RangeStats")
	proto.RegisterType((*ReplicaStatus)(nil), "statspb.ReplicaStatus")
	proto.RegisterType((*RaftStatus)(nil), "statspb.RaftStatus")
	proto.RegisterType((*SqlStats)(nil), "statspb.SqlStats")
	proto.RegisterType((*SqlSlowlog)(nil), "statspb.SqlSlowlog")
	proto.RegisterType((*SqlSlow)(nil), "statspb.SqlSlow")
	proto.RegisterType((*SqlTp)(nil), "statspb.SqlTp")
	proto.RegisterEnum("statspb.TpArgs", TpArgs_name, TpArgs_value)
}
func (m *ClusterStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DataBaseStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataBaseStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *TableStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ProcessStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CpuPercent != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Statspb(dAtA, i, uint64(math.Float64bits(float64(m.CpuPercent))))
	}
	if m.IoReadCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.IoReadCount))
	}
	if m.IoWriteCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.IoWriteCount))
	}
	if m.IoReadBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.IoReadBytes))
	}
	if m.IoWriteBytes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.IoWriteBytes))
	}
	if m.MemoryRss != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.MemoryRss))
	}
	if m.MemoryVms != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.MemoryVms))
	}
	if m.MemorySwap != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.MemorySwap))
	}
	if m.MemoryPercent != 0 {
		dAtA[i] = 0x49
		i++
		i = encodeFixed64Statspb(dAtA, i, uint64(math.Float64bits(float64(m.MemoryPercent))))
	}
	if m.NetConnectionCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetConnectionCount))
	}
	if m.NetByteSent != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetByteSent))
	}
	if m.NetByteRecv != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetByteRecv))
	}
	if m.NetPacketSent != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetPacketSent))
	}
	if m.NetPacketRecv != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetPacketRecv))
	}
	if m.NetErrIn != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetErrIn))
	}
	if m.NetErrOut != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetErrOut))
	}
	if m.NetDropIn != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetDropIn))
	}
	if m.NetDropOut != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetDropOut))
	}
	return i, nil
}

func (m *NodeStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MemoryTotal != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.MemoryTotal))
	}
	if m.MemoryUsedRss != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.MemoryUsedRss))
	}
	if m.MemoryUsed != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.MemoryUsed))
	}
	if m.MemoryFree != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.MemoryFree))
	}
	if m.MemoryUsedPercent != 0 {
		dAtA[i] = 0x29
		i++
		i = encodeFixed64Statspb(dAtA, i, uint64(math.Float64bits(float64(m.MemoryUsedPercent))))
	}
	if m.SwapMemoryTotal != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.SwapMemoryTotal))
	}
	if m.SwapMemoryUsed != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.SwapMemoryUsed))
	}
	if m.SwapMemoryFree != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.SwapMemoryFree))
	}
	if m.SwapMemoryUsedPercent != 0 {
		dAtA[i] = 0x49
		i++
		i = encodeFixed64Statspb(dAtA, i, uint64(math.Float64bits(float64(m.SwapMemoryUsedPercent))))
	}
	if m.CpuProcRate != 0 {
		dAtA[i] = 0x51
		i++
		i = encodeFixed64Statspb(dAtA, i, uint64(math.Float64bits(float64(m.CpuProcRate))))
	}
	if m.CpuCount != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.CpuCount))
	}
	if m.Load1 != 0 {
		dAtA[i] = 0x61
		i++
		i = encodeFixed64Statspb(dAtA, i, uint64(math.Float64bits(float64(m.Load1))))
	}
	if m.Load5 != 0 {
		dAtA[i] = 0x69
		i++
		i = encodeFixed64Statspb(dAtA, i, uint64(math.Float64bits(float64(m.Load5))))
	}
	if m.Load15 != 0 {
		dAtA[i] = 0x71
		i++
		i = encodeFixed64Statspb(dAtA, i, uint64(math.Float64bits(float64(m.Load15))))
	}
	if m.DiskTotal != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DiskTotal))
	}
	if m.DiskUsed != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DiskUsed))
	}
	if m.DiskFree != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DiskFree))
	}
	if m.DiskProcRate != 0 {
		dAtA[i] = 0x91
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed64Statspb(dAtA, i, uint64(math.Float64bits(float64(m.DiskProcRate))))
	}
	if m.DiskReadBytePerSec != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DiskReadBytePerSec))
	}
	if m.DiskWriteBytePerSec != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DiskWriteBytePerSec))
	}
	if m.NetIoInBytePerSec != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetIoInBytePerSec))
	}
	if m.NetIoOutBytePerSec != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetIoOutBytePerSec))
	}
	if m.NetTcpConnections != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetTcpConnections))
	}
	if m.NetTcpActiveOpensPerSec != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NetTcpActiveOpensPerSec))
	}
	if m.Ops != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Ops))
	}
	if m.RangeSplitCount != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.RangeSplitCount))
	}
	if m.SendingSnapCount != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.SendingSnapCount))
	}
	if m.ReceivingSnapCount != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.ReceivingSnapCount))
	}
	if m.ApplyingSnapCount != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.ApplyingSnapCount))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.StartTime))
	}
	return i, nil
}

func (m *RangeStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RangeStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Size_ != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Size_))
	}
	if m.Ops != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Ops))
	}
	if m.BytesInPerSec != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.BytesInPerSec))
	}
	if m.BytesOutPerSec != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.BytesOutPerSec))
	}
	if m.TotalCommandsProcessed != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.TotalCommandsProcessed))
	}
	if m.KeyspaceMisses != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.KeyspaceMisses))
	}
	return i, nil
}

func (m *ReplicaStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Match != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Match))
	}
	if m.Commit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Commit))
	}
	if m.Next != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Next))
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if m.Snapshoting {
		dAtA[i] = 0x28
		i++
		if m.Snapshoting {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Paused {
		dAtA[i] = 0x30
		i++
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Active {
		dAtA[i] = 0x38
		i++
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LastActive != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.LastActive))
	}
	if m.Inflight != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Inflight))
	}
	if m.ID != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.ID))
	}
	return i, nil
}

func (m *RaftStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.ID))
	}
	if m.NodeID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.NodeID))
	}
	if m.Leader != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Leader))
	}
	if m.Term != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Term))
	}
	if m.Index != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Index))
	}
	if m.Commit != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Commit))
	}
	if m.Applied != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Applied))
	}
	if m.Vote != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Vote))
	}
	if m.PendQueue != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.PendQueue))
	}
	if m.RecvQueue != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.RecvQueue))
	}
	if m.AppQueue != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.AppQueue))
	}
	if m.Stopped {
		dAtA[i] = 0x60
		i++
		if m.Stopped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RestoringSnapshot {
		dAtA[i] = 0x68
		i++
		if m.RestoringSnapshot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.State) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.State)))
		i += copy(dAtA[i:], m.State)
	}
	if len(m.Replicas) > 0 {
		for _, msg := range m.Replicas {
			dAtA[i] = 0x7a
			i++
			i = encodeVarintStatspb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SqlStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ops != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Ops))
	}
	if m.DelayAvg != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DelayAvg))
	}
	if len(m.Tp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.Tp)))
		i += copy(dAtA[i:], m.Tp)
	}
	return i, nil
}

func (m *SqlSlowlog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlSlowlog) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Len != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Len))
	}
	if m.Than != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Than))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Idx))
	}
	if len(m.Log) > 0 {
		for _, msg := range m.Log {
			dAtA[i] = 0x22
			i++
			i = encodeVarintStatspb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SqlSlow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlSlow) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TimeSec != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.TimeSec))
	}
	if len(m.Sql) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(len(m.Sql)))
		i += copy(dAtA[i:], m.Sql)
	}
	if m.TotalUsec != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.TotalUsec))
	}
	if m.CallUsec != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.CallUsec))
	}
	return i, nil
}

func (m *SqlTp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlTp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Calls != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.Calls))
	}
	if len(m.Tp) > 0 {
		dAtA2 := make([]byte, len(m.Tp)*10)
		var j1 int
		for _, num1 := range m.Tp {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.DelayMax != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintStatspb(dAtA, i, uint64(m.DelayMax))
	}
	return i, nil
}

func encodeFixed64Statspb(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Statspb(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintStatspb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ClusterStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *DataBaseStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *TableStats) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ProcessStats) Size() (n int) {
	var l int
	_ = l
	if m.CpuPercent != 0 {
		n += 9
	}
	if m.IoReadCount != 0 {
		n += 1 + sovStatspb(uint64(m.IoReadCount))
	}
	if m.IoWriteCount != 0 {
		n += 1 + sovStatspb(uint64(m.IoWriteCount))
	}
	if m.IoReadBytes != 0 {
		n += 1 + sovStatspb(uint64(m.IoReadBytes))
	}
	if m.IoWriteBytes != 0 {
		n += 1 + sovStatspb(uint64(m.IoWriteBytes))
	}
	if m.MemoryRss != 0 {
		n += 1 + sovStatspb(uint64(m.MemoryRss))
	}
	if m.MemoryVms != 0 {
		n += 1 + sovStatspb(uint64(m.MemoryVms))
	}
	if m.MemorySwap != 0 {
		n += 1 + sovStatspb(uint64(m.MemorySwap))
	}
	if m.MemoryPercent != 0 {
		n += 9
	}
	if m.NetConnectionCount != 0 {
		n += 1 + sovStatspb(uint64(m.NetConnectionCount))
	}
	if m.NetByteSent != 0 {
		n += 1 + sovStatspb(uint64(m.NetByteSent))
	}
	if m.NetByteRecv != 0 {
		n += 1 + sovStatspb(uint64(m.NetByteRecv))
	}
	if m.NetPacketSent != 0 {
		n += 1 + sovStatspb(uint64(m.NetPacketSent))
	}
	if m.NetPacketRecv != 0 {
		n += 1 + sovStatspb(uint64(m.NetPacketRecv))
	}
	if m.NetErrIn != 0 {
		n += 1 + sovStatspb(uint64(m.NetErrIn))
	}
	if m.NetErrOut != 0 {
		n += 2 + sovStatspb(uint64(m.NetErrOut))
	}
	if m.NetDropIn != 0 {
		n += 2 + sovStatspb(uint64(m.NetDropIn))
	}
	if m.NetDropOut != 0 {
		n += 2 + sovStatspb(uint64(m.NetDropOut))
	}
	return n
}

func (m *NodeStats) Size() (n int) {
	var l int
	_ = l
	if m.MemoryTotal != 0 {
		n += 1 + sovStatspb(uint64(m.MemoryTotal))
	}
	if m.MemoryUsedRss != 0 {
		n += 1 + sovStatspb(uint64(m.MemoryUsedRss))
	}
	if m.MemoryUsed != 0 {
		n += 1 + sovStatspb(uint64(m.MemoryUsed))
	}
	if m.MemoryFree != 0 {
		n += 1 + sovStatspb(uint64(m.MemoryFree))
	}
	if m.MemoryUsedPercent != 0 {
		n += 9
	}
	if m.SwapMemoryTotal != 0 {
		n += 1 + sovStatspb(uint64(m.SwapMemoryTotal))
	}
	if m.SwapMemoryUsed != 0 {
		n += 1 + sovStatspb(uint64(m.SwapMemoryUsed))
	}
	if m.SwapMemoryFree != 0 {
		n += 1 + sovStatspb(uint64(m.SwapMemoryFree))
	}
	if m.SwapMemoryUsedPercent != 0 {
		n += 9
	}
	if m.CpuProcRate != 0 {
		n += 9
	}
	if m.CpuCount != 0 {
		n += 1 + sovStatspb(uint64(m.CpuCount))
	}
	if m.Load1 != 0 {
		n += 9
	}
	if m.Load5 != 0 {
		n += 9
	}
	if m.Load15 != 0 {
		n += 9
	}
	if m.DiskTotal != 0 {
		n += 1 + sovStatspb(uint64(m.DiskTotal))
	}
	if m.DiskUsed != 0 {
		n += 2 + sovStatspb(uint64(m.DiskUsed))
	}
	if m.DiskFree != 0 {
		n += 2 + sovStatspb(uint64(m.DiskFree))
	}
	if m.DiskProcRate != 0 {
		n += 10
	}
	if m.DiskReadBytePerSec != 0 {
		n += 2 + sovStatspb(uint64(m.DiskReadBytePerSec))
	}
	if m.DiskWriteBytePerSec != 0 {
		n += 2 + sovStatspb(uint64(m.DiskWriteBytePerSec))
	}
	if m.NetIoInBytePerSec != 0 {
		n += 2 + sovStatspb(uint64(m.NetIoInBytePerSec))
	}
	if m.NetIoOutBytePerSec != 0 {
		n += 2 + sovStatspb(uint64(m.NetIoOutBytePerSec))
	}
	if m.NetTcpConnections != 0 {
		n += 2 + sovStatspb(uint64(m.NetTcpConnections))
	}
	if m.NetTcpActiveOpensPerSec != 0 {
		n += 2 + sovStatspb(uint64(m.NetTcpActiveOpensPerSec))
	}
	if m.Ops != 0 {
		n += 2 + sovStatspb(uint64(m.Ops))
	}
	if m.RangeSplitCount != 0 {
		n += 2 + sovStatspb(uint64(m.RangeSplitCount))
	}
	if m.SendingSnapCount != 0 {
		n += 2 + sovStatspb(uint64(m.SendingSnapCount))
	}
	if m.ReceivingSnapCount != 0 {
		n += 2 + sovStatspb(uint64(m.ReceivingSnapCount))
	}
	if m.ApplyingSnapCount != 0 {
		n += 2 + sovStatspb(uint64(m.ApplyingSnapCount))
	}
	if m.StartTime != 0 {
		n += 2 + sovStatspb(uint64(m.StartTime))
	}
	return n
}

func (m *RangeStats) Size() (n int) {
	var l int
	_ = l
	if m.Size_ != 0 {
		n += 1 + sovStatspb(uint64(m.Size_))
	}
	if m.Ops != 0 {
		n += 1 + sovStatspb(uint64(m.Ops))
	}
	if m.BytesInPerSec != 0 {
		n += 1 + sovStatspb(uint64(m.BytesInPerSec))
	}
	if m.BytesOutPerSec != 0 {
		n += 1 + sovStatspb(uint64(m.BytesOutPerSec))
	}
	if m.TotalCommandsProcessed != 0 {
		n += 1 + sovStatspb(uint64(m.TotalCommandsProcessed))
	}
	if m.KeyspaceMisses != 0 {
		n += 1 + sovStatspb(uint64(m.KeyspaceMisses))
	}
	return n
}

func (m *ReplicaStatus) Size() (n int) {
	var l int
	_ = l
	if m.Match != 0 {
		n += 1 + sovStatspb(uint64(m.Match))
	}
	if m.Commit != 0 {
		n += 1 + sovStatspb(uint64(m.Commit))
	}
	if m.Next != 0 {
		n += 1 + sovStatspb(uint64(m.Next))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.Snapshoting {
		n += 2
	}
	if m.Paused {
		n += 2
	}
	if m.Active {
		n += 2
	}
	if m.LastActive != 0 {
		n += 1 + sovStatspb(uint64(m.LastActive))
	}
	if m.Inflight != 0 {
		n += 1 + sovStatspb(uint64(m.Inflight))
	}
	if m.ID != 0 {
		n += 1 + sovStatspb(uint64(m.ID))
	}
	return n
}

func (m *RaftStatus) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovStatspb(uint64(m.ID))
	}
	if m.NodeID != 0 {
		n += 1 + sovStatspb(uint64(m.NodeID))
	}
	if m.Leader != 0 {
		n += 1 + sovStatspb(uint64(m.Leader))
	}
	if m.Term != 0 {
		n += 1 + sovStatspb(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovStatspb(uint64(m.Index))
	}
	if m.Commit != 0 {
		n += 1 + sovStatspb(uint64(m.Commit))
	}
	if m.Applied != 0 {
		n += 1 + sovStatspb(uint64(m.Applied))
	}
	if m.Vote != 0 {
		n += 1 + sovStatspb(uint64(m.Vote))
	}
	if m.PendQueue != 0 {
		n += 1 + sovStatspb(uint64(m.PendQueue))
	}
	if m.RecvQueue != 0 {
		n += 1 + sovStatspb(uint64(m.RecvQueue))
	}
	if m.AppQueue != 0 {
		n += 1 + sovStatspb(uint64(m.AppQueue))
	}
	if m.Stopped {
		n += 2
	}
	if m.RestoringSnapshot {
		n += 2
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.Size()
			n += 1 + l + sovStatspb(uint64(l))
		}
	}
	return n
}

func (m *SqlStats) Size() (n int) {
	var l int
	_ = l
	if m.Ops != 0 {
		n += 1 + sovStatspb(uint64(m.Ops))
	}
	if m.DelayAvg != 0 {
		n += 1 + sovStatspb(uint64(m.DelayAvg))
	}
	l = len(m.Tp)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	return n
}

func (m *SqlSlowlog) Size() (n int) {
	var l int
	_ = l
	if m.Len != 0 {
		n += 1 + sovStatspb(uint64(m.Len))
	}
	if m.Than != 0 {
		n += 1 + sovStatspb(uint64(m.Than))
	}
	if m.Idx != 0 {
		n += 1 + sovStatspb(uint64(m.Idx))
	}
	if len(m.Log) > 0 {
		for _, e := range m.Log {
			l = e.Size()
			n += 1 + l + sovStatspb(uint64(l))
		}
	}
	return n
}

func (m *SqlSlow) Size() (n int) {
	var l int
	_ = l
	if m.TimeSec != 0 {
		n += 1 + sovStatspb(uint64(m.TimeSec))
	}
	l = len(m.Sql)
	if l > 0 {
		n += 1 + l + sovStatspb(uint64(l))
	}
	if m.TotalUsec != 0 {
		n += 1 + sovStatspb(uint64(m.TotalUsec))
	}
	if m.CallUsec != 0 {
		n += 1 + sovStatspb(uint64(m.CallUsec))
	}
	return n
}

func (m *SqlTp) Size() (n int) {
	var l int
	_ = l
	if m.Calls != 0 {
		n += 1 + sovStatspb(uint64(m.Calls))
	}
	if len(m.Tp) > 0 {
		l = 0
		for _, e := range m.Tp {
			l += sovStatspb(uint64(e))
		}
		n += 1 + sovStatspb(uint64(l)) + l
	}
	if m.DelayMax != 0 {
		n += 1 + sovStatspb(uint64(m.DelayMax))
	}
	return n
}

func sovStatspb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStatspb(x uint64) (n int) {
	return sovStatspb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClusterStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataBaseStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataBaseStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataBaseStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.CpuPercent = float64(math.Float64frombits(v))
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoReadCount", wireType)
			}
			m.IoReadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IoReadCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoWriteCount", wireType)
			}
			m.IoWriteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IoWriteCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoReadBytes", wireType)
			}
			m.IoReadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IoReadBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoWriteBytes", wireType)
			}
			m.IoWriteBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IoWriteBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryRss", wireType)
			}
			m.MemoryRss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryRss |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryVms", wireType)
			}
			m.MemoryVms = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryVms |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySwap", wireType)
			}
			m.MemorySwap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySwap |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MemoryPercent = float64(math.Float64frombits(v))
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetConnectionCount", wireType)
			}
			m.NetConnectionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetConnectionCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetByteSent", wireType)
			}
			m.NetByteSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetByteSent |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetByteRecv", wireType)
			}
			m.NetByteRecv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetByteRecv |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetPacketSent", wireType)
			}
			m.NetPacketSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetPacketSent |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetPacketRecv", wireType)
			}
			m.NetPacketRecv = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetPacketRecv |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetErrIn", wireType)
			}
			m.NetErrIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetErrIn |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetErrOut", wireType)
			}
			m.NetErrOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetErrOut |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetDropIn", wireType)
			}
			m.NetDropIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetDropIn |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetDropOut", wireType)
			}
			m.NetDropOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetDropOut |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryTotal", wireType)
			}
			m.MemoryTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryTotal |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryUsedRss", wireType)
			}
			m.MemoryUsedRss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryUsedRss |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryUsed", wireType)
			}
			m.MemoryUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryUsed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryFree", wireType)
			}
			m.MemoryFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryFree |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryUsedPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.MemoryUsedPercent = float64(math.Float64frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapMemoryTotal", wireType)
			}
			m.SwapMemoryTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapMemoryTotal |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapMemoryUsed", wireType)
			}
			m.SwapMemoryUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapMemoryUsed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapMemoryFree", wireType)
			}
			m.SwapMemoryFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwapMemoryFree |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapMemoryUsedPercent", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.SwapMemoryUsedPercent = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuProcRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.CpuProcRate = float64(math.Float64frombits(v))
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCount", wireType)
			}
			m.CpuCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load1", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Load1 = float64(math.Float64frombits(v))
		case 13:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load5", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Load5 = float64(math.Float64frombits(v))
		case 14:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load15", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Load15 = float64(math.Float64frombits(v))
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskTotal", wireType)
			}
			m.DiskTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskTotal |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskUsed", wireType)
			}
			m.DiskUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskUsed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskFree", wireType)
			}
			m.DiskFree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskFree |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskProcRate", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.DiskProcRate = float64(math.Float64frombits(v))
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskReadBytePerSec", wireType)
			}
			m.DiskReadBytePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskReadBytePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskWriteBytePerSec", wireType)
			}
			m.DiskWriteBytePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskWriteBytePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetIoInBytePerSec", wireType)
			}
			m.NetIoInBytePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetIoInBytePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetIoOutBytePerSec", wireType)
			}
			m.NetIoOutBytePerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetIoOutBytePerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTcpConnections", wireType)
			}
			m.NetTcpConnections = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetTcpConnections |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetTcpActiveOpensPerSec", wireType)
			}
			m.NetTcpActiveOpensPerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetTcpActiveOpensPerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			m.Ops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ops |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangeSplitCount", wireType)
			}
			m.RangeSplitCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RangeSplitCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendingSnapCount", wireType)
			}
			m.SendingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendingSnapCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivingSnapCount", wireType)
			}
			m.ReceivingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceivingSnapCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyingSnapCount", wireType)
			}
			m.ApplyingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyingSnapCount |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RangeStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RangeStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RangeStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			m.Ops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ops |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesInPerSec", wireType)
			}
			m.BytesInPerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesInPerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesOutPerSec", wireType)
			}
			m.BytesOutPerSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesOutPerSec |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCommandsProcessed", wireType)
			}
			m.TotalCommandsProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCommandsProcessed |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyspaceMisses", wireType)
			}
			m.KeyspaceMisses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyspaceMisses |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Match", wireType)
			}
			m.Match = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Match |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			m.Next = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Next |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshoting", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Snapshoting = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastActive", wireType)
			}
			m.LastActive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastActive |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inflight", wireType)
			}
			m.Inflight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Inflight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Applied", wireType)
			}
			m.Applied = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Applied |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			m.Vote = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vote |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendQueue", wireType)
			}
			m.PendQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendQueue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvQueue", wireType)
			}
			m.RecvQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecvQueue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppQueue", wireType)
			}
			m.AppQueue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppQueue |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stopped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stopped = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestoringSnapshot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RestoringSnapshot = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, &ReplicaStatus{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ops", wireType)
			}
			m.Ops = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ops |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayAvg", wireType)
			}
			m.DelayAvg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayAvg |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tp = append(m.Tp[:0], dAtA[iNdEx:postIndex]...)
			if m.Tp == nil {
				m.Tp = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlSlowlog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlSlowlog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlSlowlog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Than", wireType)
			}
			m.Than = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Than |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Log", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Log = append(m.Log, &SqlSlow{})
			if err := m.Log[len(m.Log)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlSlow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlSlow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlSlow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSec", wireType)
			}
			m.TimeSec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeSec |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sql", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStatspb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sql = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsec", wireType)
			}
			m.TotalUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUsec |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallUsec", wireType)
			}
			m.CallUsec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CallUsec |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlTp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlTp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlTp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Calls", wireType)
			}
			m.Calls = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Calls |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatspb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Tp = append(m.Tp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowStatspb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthStatspb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowStatspb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Tp = append(m.Tp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Tp", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelayMax", wireType)
			}
			m.DelayMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DelayMax |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStatspb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStatspb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStatspb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStatspb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStatspb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStatspb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStatspb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStatspb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStatspb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStatspb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("statspb.proto", fileDescriptorStatspb) }

var fileDescriptorStatspb = []byte{
	// 1536 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x57, 0xdd, 0x72, 0xdb, 0xba,
	0x11, 0x8e, 0x2c, 0xff, 0x50, 0xab, 0x5f, 0xc3, 0x8e, 0xc3, 0x24, 0x8e, 0xeb, 0x6a, 0x92, 0xc6,
	0xc9, 0x64, 0xdc, 0xfc, 0x34, 0xd3, 0xde, 0xf4, 0xc2, 0xb1, 0x9b, 0x19, 0x75, 0xe2, 0xd8, 0xa5,
	0x9c, 0xf4, 0x92, 0x03, 0x93, 0x88, 0xcc, 0x09, 0x45, 0x20, 0x04, 0x28, 0xdb, 0xbd, 0xef, 0x13,
	0xf4, 0xa6, 0x0f, 0xd0, 0xf6, 0x05, 0xfa, 0x12, 0xbd, 0xec, 0x23, 0x74, 0xd2, 0x9b, 0x73, 0xde,
	0xe2, 0xcc, 0x2e, 0x40, 0x8a, 0xd2, 0xb9, 0xe3, 0xee, 0xf7, 0xed, 0x02, 0xf8, 0x76, 0xb1, 0x90,
	0xa0, 0xab, 0x0d, 0x37, 0x5a, 0x5d, 0x1e, 0xaa, 0x5c, 0x1a, 0xc9, 0x36, 0x9c, 0xf9, 0x60, 0x7b,
	0x22, 0x27, 0x92, 0x7c, 0xbf, 0xc6, 0x2f, 0x0b, 0x0f, 0x7b, 0xd0, 0x39, 0x4e, 0x0b, 0x6d, 0x44,
	0x3e, 0x46, 0xde, 0xb0, 0x0f, 0xdd, 0x13, 0x6e, 0xf8, 0x3b, 0xae, 0x85, 0x75, 0x74, 0x00, 0x2e,
	0xf8, 0x65, 0xea, 0xac, 0xbf, 0xad, 0x41, 0xe7, 0x3c, 0x97, 0x91, 0xd0, 0x9a, 0x1c, 0xec, 0x17,
	0xd0, 0x8e, 0x54, 0x11, 0x2a, 0x91, 0x47, 0x22, 0x33, 0x7e, 0x63, 0xbf, 0x71, 0xd0, 0x08, 0x20,
	0x52, 0xc5, 0xb9, 0xf5, 0xb0, 0x21, 0x74, 0x13, 0x19, 0xe6, 0x82, 0xc7, 0x61, 0x24, 0x8b, 0xcc,
	0xf8, 0x2b, 0xfb, 0x8d, 0x83, 0xd5, 0xa0, 0x9d, 0xc8, 0x40, 0xf0, 0xf8, 0x18, 0x5d, 0xec, 0x31,
	0xf4, 0x12, 0x19, 0x5e, 0xe7, 0x89, 0x11, 0x8e, 0xd4, 0x24, 0x52, 0x27, 0x91, 0x7f, 0x46, 0xa7,
	0x65, 0xd5, 0x32, 0x5d, 0xde, 0x1a, 0xa1, 0xfd, 0xd5, 0x7a, 0xa6, 0x77, 0xe8, 0x5a, 0xc8, 0x64,
	0x49, 0x6b, 0x0b, 0x99, 0x2c, 0xeb, 0x11, 0xc0, 0x54, 0x4c, 0x65, 0x7e, 0x1b, 0xe6, 0x5a, 0xfb,
	0xeb, 0xc4, 0x68, 0x59, 0x4f, 0xa0, 0xeb, 0xf0, 0x6c, 0xaa, 0xfd, 0x8d, 0x3a, 0xfc, 0x79, 0x4a,
	0x47, 0x76, 0xb0, 0xbe, 0xe6, 0xca, 0xf7, 0x08, 0x77, 0x11, 0xe3, 0x6b, 0xae, 0xd8, 0x13, 0xe8,
	0x39, 0x42, 0x29, 0x4b, 0x8b, 0x64, 0xe9, 0x5a, 0x6f, 0xa9, 0xcc, 0x4b, 0xd8, 0xce, 0x84, 0x09,
	0x23, 0x99, 0x65, 0x22, 0x32, 0x89, 0xcc, 0xdc, 0xd9, 0x81, 0x12, 0xb2, 0x4c, 0x98, 0xe3, 0x0a,
	0xaa, 0x14, 0xc0, 0x08, 0x3c, 0x58, 0xa8, 0x31, 0x6f, 0xdb, 0x2a, 0x90, 0x09, 0x83, 0x07, 0x1b,
	0x8b, 0x25, 0x4e, 0x2e, 0xa2, 0x99, 0xdf, 0x59, 0xe0, 0x04, 0x22, 0x9a, 0xb1, 0x5f, 0x41, 0x1f,
	0x39, 0x8a, 0x47, 0x5f, 0x85, 0xb1, 0x99, 0xba, 0xc4, 0xc2, 0xd0, 0x73, 0xf2, 0x52, 0xae, 0x45,
	0x1e, 0x65, 0xeb, 0x2d, 0xf1, 0x28, 0xdf, 0x2e, 0x00, 0xf2, 0x44, 0x9e, 0x87, 0x49, 0xe6, 0xf7,
	0x89, 0xe2, 0x65, 0xc2, 0xfc, 0x21, 0xcf, 0x47, 0x19, 0xdb, 0x83, 0x76, 0x89, 0xca, 0xc2, 0xf8,
	0x03, 0xab, 0xa7, 0x85, 0xcf, 0x0a, 0x53, 0xe2, 0x71, 0x2e, 0x15, 0x86, 0x6f, 0x56, 0xf8, 0x49,
	0x2e, 0xd5, 0x28, 0x63, 0xfb, 0xd0, 0xa9, 0x70, 0x4c, 0xc0, 0xac, 0xe0, 0x8e, 0x70, 0x56, 0x98,
	0xe1, 0xbf, 0x5b, 0xd0, 0xfa, 0x28, 0x63, 0xdb, 0xa3, 0xec, 0x97, 0xd0, 0x71, 0xf2, 0x1b, 0x69,
	0x78, 0x4a, 0x3d, 0xb9, 0x1a, 0xb8, 0x9a, 0x5d, 0xa0, 0x0b, 0x0f, 0xe6, 0x28, 0x85, 0x16, 0x31,
	0x75, 0x81, 0x6d, 0x4b, 0x57, 0xa2, 0x4f, 0x5a, 0xc4, 0xd8, 0x09, 0xf3, 0x52, 0x23, 0xcf, 0x75,
	0x25, 0xcc, 0x39, 0x35, 0xc2, 0x97, 0x5c, 0x08, 0xd7, 0x91, 0x8e, 0xf0, 0x3e, 0x17, 0x82, 0x1d,
	0xc2, 0x56, 0x7d, 0xa5, 0xb2, 0x21, 0xd6, 0xa8, 0x21, 0x36, 0xe7, 0x99, 0xca, 0xa6, 0x78, 0x0e,
	0x9b, 0xd8, 0x55, 0xe1, 0xc2, 0x09, 0x6c, 0x87, 0xf6, 0x11, 0x38, 0xad, 0x9d, 0xe2, 0x00, 0x06,
	0x75, 0x2e, 0x6d, 0xd1, 0x76, 0x6b, 0x6f, 0x4e, 0xa5, 0x6d, 0x2e, 0x31, 0x69, 0xaf, 0xde, 0x32,
	0x93, 0xf6, 0xfb, 0x5b, 0xf0, 0x97, 0x73, 0x2e, 0x75, 0xf1, 0xdd, 0xc5, 0xdc, 0xb5, 0x7b, 0x4e,
	0x83, 0x20, 0x97, 0x51, 0x98, 0x73, 0x23, 0xa8, 0x8d, 0x1b, 0x01, 0x4e, 0x07, 0x1c, 0x18, 0x01,
	0x37, 0x82, 0x3d, 0x84, 0x16, 0x72, 0x6c, 0x9b, 0x63, 0xef, 0x76, 0x03, 0x2f, 0x52, 0x85, 0x6d,
	0xee, 0x6d, 0x58, 0x4b, 0x25, 0x8f, 0x5f, 0x51, 0xc3, 0x36, 0x02, 0x6b, 0x94, 0xde, 0xb7, 0xd4,
	0xa0, 0xce, 0xfb, 0x96, 0xed, 0xc0, 0x3a, 0xc1, 0x6f, 0xa9, 0x1f, 0x1b, 0x81, 0xb3, 0xf0, 0xe6,
	0xc6, 0x89, 0xfe, 0xea, 0x64, 0xb3, 0x8d, 0xd8, 0x42, 0x8f, 0x15, 0xec, 0x21, 0x90, 0x61, 0x95,
	0xb2, 0x7d, 0xe8, 0xa1, 0x83, 0x34, 0x2a, 0x41, 0x12, 0x67, 0x73, 0x0e, 0x92, 0x2c, 0x8f, 0xa1,
	0x47, 0xe0, 0xfc, 0x78, 0x8c, 0x16, 0xee, 0xa0, 0xb7, 0x3a, 0xdf, 0x6b, 0xd8, 0x21, 0x56, 0x35,
	0xa3, 0x50, 0xba, 0x50, 0x8b, 0xc8, 0xdf, 0xb6, 0x77, 0x1a, 0xd1, 0x72, 0x58, 0x9d, 0x8b, 0x7c,
	0x2c, 0x22, 0xf6, 0x1b, 0xb8, 0x47, 0x31, 0xf3, 0x99, 0x55, 0x05, 0xdd, 0xa5, 0xa0, 0x2d, 0x84,
	0xab, 0xe1, 0xe5, 0xa2, 0x5e, 0xc1, 0x0e, 0xde, 0x89, 0x44, 0x86, 0x49, 0xb6, 0x18, 0xe4, 0x53,
	0xd0, 0x66, 0x26, 0xcc, 0x48, 0x8e, 0xb2, 0x5a, 0xc8, 0x1b, 0xb8, 0xe7, 0x42, 0x64, 0x61, 0x16,
	0x63, 0xee, 0x57, 0x13, 0x67, 0x24, 0xcf, 0x0a, 0x53, 0x0b, 0x3a, 0x84, 0x2d, 0x0c, 0x32, 0x91,
	0xaa, 0xcd, 0x29, 0xed, 0xef, 0x52, 0xed, 0x70, 0x91, 0x8b, 0x48, 0xcd, 0xa7, 0x94, 0x66, 0xbf,
	0x87, 0xdd, 0x92, 0xcf, 0x23, 0x93, 0xcc, 0x44, 0x28, 0x95, 0xc8, 0x74, 0xb5, 0xd2, 0x23, 0x5a,
	0xe9, 0x9e, 0x0d, 0x3c, 0x22, 0xc6, 0x19, 0x12, 0xdc, 0x72, 0x03, 0x68, 0x4a, 0xa5, 0xfd, 0x27,
	0xc4, 0xc2, 0x4f, 0xbc, 0x0f, 0x39, 0xcf, 0x26, 0x22, 0xd4, 0x2a, 0x4d, 0x8c, 0x6b, 0x9d, 0xa7,
	0xb4, 0x7c, 0x9f, 0x80, 0x31, 0xfa, 0x6d, 0x07, 0xbd, 0x00, 0xa6, 0x45, 0x16, 0x27, 0xd9, 0x24,
	0xd4, 0x19, 0x57, 0x8e, 0x7c, 0x40, 0xe4, 0x81, 0x43, 0xc6, 0x19, 0x57, 0x96, 0xfd, 0x12, 0xb6,
	0x73, 0x11, 0x89, 0x64, 0xb6, 0xc4, 0x7f, 0x46, 0x7c, 0x56, 0x61, 0xf3, 0x88, 0x43, 0xd8, 0xe2,
	0x4a, 0xa5, 0xb7, 0x4b, 0x01, 0xcf, 0xad, 0x18, 0x25, 0x34, 0xe7, 0x3f, 0x02, 0xd0, 0x86, 0xe7,
	0x26, 0x34, 0xc9, 0x54, 0xf8, 0x2f, 0x88, 0xd6, 0x22, 0xcf, 0x45, 0x32, 0x15, 0xc3, 0x1f, 0x1b,
	0x00, 0x01, 0x1d, 0x81, 0xc6, 0x16, 0x83, 0x55, 0x9d, 0xfc, 0x45, 0xb8, 0x71, 0x45, 0xdf, 0xa5,
	0x1e, 0x2b, 0x73, 0x3d, 0x9e, 0xc2, 0x80, 0xde, 0x35, 0xac, 0x7b, 0x29, 0xaa, 0x1d, 0x4b, 0x5d,
	0xf2, 0x8f, 0x32, 0x27, 0xe5, 0x33, 0xd8, 0xb4, 0x44, 0xac, 0x76, 0xc9, 0xb4, 0xf3, 0xa9, 0x47,
	0xc0, 0x59, 0x61, 0x1c, 0xf5, 0x77, 0xe0, 0xd3, 0x85, 0x09, 0x23, 0x39, 0x9d, 0xf2, 0x2c, 0xd6,
	0xd4, 0xe6, 0x42, 0xe3, 0x2d, 0xb1, 0xcf, 0xe7, 0x0e, 0xe1, 0xc7, 0x0e, 0x3e, 0x2f, 0x51, 0xf6,
	0x14, 0xfa, 0x5f, 0xc5, 0xad, 0x56, 0x3c, 0x12, 0xe1, 0x34, 0xd1, 0x5a, 0x94, 0xaf, 0x69, 0xaf,
	0x74, 0x9f, 0x92, 0x77, 0xf8, 0xd7, 0x15, 0xe8, 0x06, 0x42, 0xa5, 0x49, 0xc4, 0xf1, 0xb4, 0x85,
	0xc6, 0x8b, 0x7d, 0xca, 0x4d, 0x74, 0xe5, 0xce, 0x6b, 0x0d, 0xbc, 0xd8, 0xb8, 0x4a, 0x52, 0xfe,
	0x4c, 0x70, 0x16, 0x8a, 0xf3, 0x51, 0xdc, 0x94, 0xbf, 0x0b, 0xe8, 0x1b, 0x33, 0x60, 0x2e, 0x3b,
	0x75, 0x5b, 0x81, 0x35, 0xd8, 0x3e, 0xb4, 0xb1, 0x02, 0xfa, 0x4a, 0x9a, 0x24, 0x9b, 0xd0, 0xfe,
	0xbd, 0xa0, 0xee, 0xc2, 0x35, 0xce, 0x39, 0x8d, 0x80, 0x75, 0x02, 0x9d, 0x85, 0x7e, 0xdb, 0x91,
	0x34, 0x44, 0xbd, 0xc0, 0x59, 0x6c, 0x0f, 0xe0, 0x03, 0xd7, 0xc6, 0x61, 0x38, 0x36, 0x9b, 0x41,
	0xcd, 0xc3, 0x1e, 0x80, 0x37, 0xca, 0xbe, 0xa4, 0xc9, 0xe4, 0xca, 0x8e, 0xc8, 0xb5, 0xa0, 0xb2,
	0x59, 0x0f, 0x56, 0x46, 0x27, 0xee, 0x45, 0x5f, 0x19, 0x9d, 0x0c, 0xff, 0xd5, 0xc4, 0x9a, 0x7f,
	0x31, 0x4e, 0x04, 0x0b, 0x37, 0x4a, 0x18, 0xb7, 0x80, 0xef, 0xd8, 0xe8, 0xa4, 0x3c, 0xbe, 0xb5,
	0xd0, 0xff, 0x41, 0xf0, 0x58, 0xe4, 0x4e, 0x00, 0x67, 0xa1, 0x2c, 0x17, 0x22, 0x9f, 0xba, 0xba,
	0xd2, 0x37, 0xca, 0x32, 0xca, 0x62, 0x71, 0xe3, 0x4a, 0x67, 0x8d, 0x9a, 0xb0, 0xeb, 0x0b, 0xc2,
	0xfa, 0xb0, 0x71, 0xa4, 0x54, 0x9a, 0x54, 0x4f, 0x47, 0x69, 0x62, 0xee, 0xcf, 0xd2, 0x94, 0xef,
	0x04, 0x7d, 0xb3, 0x5d, 0x68, 0x9d, 0x8b, 0x2c, 0xfe, 0x53, 0x21, 0x0a, 0xe1, 0xce, 0x3a, 0x77,
	0x20, 0x8a, 0x3f, 0x07, 0x2c, 0x0a, 0x16, 0xad, 0x1c, 0x28, 0xd3, 0x91, 0x52, 0x16, 0x6c, 0x5b,
	0x99, 0x4a, 0x1b, 0x77, 0x31, 0x36, 0x52, 0x29, 0x11, 0xd3, 0xf4, 0xf7, 0x82, 0xd2, 0x64, 0x2f,
	0x60, 0x33, 0x10, 0xda, 0xc8, 0xdc, 0xdd, 0x2c, 0x2c, 0x22, 0xbd, 0x05, 0x5e, 0xf0, 0x73, 0x60,
	0xde, 0x12, 0xbd, 0x7a, 0x4b, 0xbc, 0x06, 0xcf, 0xf5, 0x9e, 0xf6, 0xfb, 0xfb, 0xcd, 0x83, 0xf6,
	0xeb, 0x9d, 0xc3, 0xf2, 0x47, 0xf2, 0x42, 0x53, 0x06, 0x15, 0x6f, 0x38, 0x02, 0x6f, 0xfc, 0x2d,
	0xb5, 0x37, 0xd3, 0xdd, 0xc2, 0x06, 0x55, 0x9e, 0x6e, 0x21, 0xbe, 0x15, 0x22, 0xe5, 0xb7, 0x21,
	0x9f, 0x4d, 0xa8, 0x54, 0xcd, 0xc0, 0x23, 0xc7, 0xd1, 0x6c, 0x82, 0x45, 0x35, 0x8a, 0x0a, 0xd5,
	0x09, 0x56, 0x8c, 0x1a, 0x5e, 0x01, 0x60, 0xaa, 0x54, 0x5e, 0xa7, 0x72, 0x82, 0xc9, 0x52, 0x91,
	0x51, 0xb2, 0x6e, 0x80, 0x9f, 0x28, 0xb4, 0xb9, 0xe2, 0x19, 0xe5, 0x59, 0x0b, 0xe8, 0x1b, 0x59,
	0x49, 0x7c, 0x43, 0x49, 0xba, 0x01, 0x7e, 0xb2, 0x21, 0x34, 0x53, 0x39, 0xf1, 0x57, 0x69, 0xff,
	0x83, 0x6a, 0xff, 0x2e, 0x73, 0x80, 0xe0, 0x30, 0x87, 0x0d, 0x67, 0xb3, 0xfb, 0xe0, 0xe1, 0xd4,
	0xa1, 0x5b, 0x6f, 0x37, 0xbe, 0x81, 0xb6, 0x1b, 0xb2, 0xfa, 0x5b, 0x4a, 0xcb, 0xb5, 0x02, 0xfc,
	0xc4, 0x41, 0x65, 0x07, 0x40, 0x51, 0x8e, 0x93, 0x66, 0xd0, 0x22, 0xcf, 0x27, 0x2d, 0x22, 0x7a,
	0xb6, 0x79, 0xea, 0xd0, 0x55, 0x7b, 0x5a, 0x74, 0x20, 0x38, 0xfc, 0x23, 0xac, 0x8d, 0xbf, 0xa5,
	0x17, 0x0a, 0xb5, 0x47, 0x67, 0xa9, 0x93, 0x35, 0x9c, 0x18, 0x2b, 0xfb, 0xcd, 0x83, 0x26, 0x8a,
	0x31, 0x57, 0x6e, 0xca, 0x6f, 0xdc, 0x4a, 0x56, 0xb9, 0x53, 0x7e, 0xf3, 0xfc, 0x3d, 0xac, 0x5f,
	0xa8, 0xa3, 0x7c, 0xa2, 0x59, 0x1b, 0x36, 0x92, 0x6c, 0xc6, 0xd3, 0x24, 0x1e, 0xdc, 0x61, 0x7d,
	0x80, 0xa9, 0x16, 0x51, 0x98, 0x60, 0x27, 0x0f, 0x7e, 0xd8, 0x60, 0x3d, 0x68, 0xcd, 0xed, 0x7f,
	0x78, 0x68, 0x4f, 0x93, 0xcc, 0xd9, 0xff, 0xf4, 0xde, 0x0d, 0xfe, 0xf3, 0x7d, 0xaf, 0xf1, 0xdf,
	0xef, 0x7b, 0x8d, 0xff, 0x7d, 0xdf, 0x6b, 0xfc, 0xfd, 0xff, 0x7b, 0x77, 0x2e, 0xd7, 0xe9, 0xdf,
	0xce, 0x9b, 0x9f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xee, 0x39, 0x34, 0x71, 0x1d, 0x0d, 0x00, 0x00,
}
